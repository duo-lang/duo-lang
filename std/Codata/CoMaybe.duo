module Codata.CoMaybe;

import Codata.Function;
import Data.Cofunction;
import Data.NegationP;
import Data.Bool;
import Prim.I64;

-- | The Maybe type encapsulates optional values.
data Maybe : (+a : CBV) -> CBV {
  Nothing,
  Just(a)
};

def prd unit : forall a. a -> Maybe(a) := \x => Just(x);
def prd bind : forall a b. Maybe(a) -> (a -> Maybe(b)) -> Maybe(b) := 
  \x f => case x of {
    Nothing => Nothing,
    Just(y) => f y
  };
def prd join : forall a. Maybe(Maybe(a)) -> Maybe(a) :=
    \x => case x of {
        Nothing => Nothing,
        Just(y) => y
    };
def prd map : forall a b. (a -> b) -> Maybe(a) -> Maybe(b) :=
    \f x => case x of {
        Nothing => Nothing,
        Just(y) => Just(f y)
    };
def prd bind2 : forall a b. Maybe(a) -> (a -> Maybe(b)) -> Maybe(b) :=
    \m f => join (map f m);

codata CoMaybe : ( +a : CBV ) -> CBV {
    CoNothing,
    CoJust( return a )
};

def cns counit : ∀ a. a -< CoMaybe( a ) := \cox =< CoJust( cox );
def cns cobind : ∀ a b. CoMaybe( a ) -< ( a -< CoMaybe( b ) ) -< CoMaybe( b ) :=
    \cox cof =< cocase cox of {
        CoNothing() => CoNothing,
        CoJust(k1) => (cof k1)
    };
def cns cojoin : ∀ a. CoMaybe( CoMaybe( a ) ) -< CoMaybe( a ) :=
    \cox =< cocase cox of {
        CoNothing() => CoNothing,
        CoJust(k1) => k1
    };
def cns comap : ∀ a b. (a -< b) -< CoMaybe( a ) -< CoMaybe( b ) :=
    \cof cox =< cocase cox of {
        CoNothing() => CoNothing,
        CoJust(k1) => CoJust( (cof k1) )
    };
def cns cobind2 : ∀ a b. CoMaybe( a ) -< ( a -< CoMaybe( b ) ) -< CoMaybe( b ) :=
    \com cof =< cojoin ((comap cof) com);

def prd cofun2fun: forall a b. Notp(a -< b) -> (b -> a) := 
  cocase { Ap(x,k) => x >> case { MkNotp(ku) => cocase { Ap(y,k2) => CoAp(k2,y) >> ku  } >> k  }};  

def prd counitp: forall a.  CoMaybe(a) -> a := cocase { Ap(x,k) => x >> CoJust(k) }; 

def prd cojoinp : forall a. CoMaybe(a) -> CoMaybe(CoMaybe(a)) := cofun2fun MkNotp(cojoin);
def prd test : CoMaybe(I64) := cocase {
    CoNothing => #ExitFailure,
    CoJust(k) => MkI64(42#I64) >> k
};
-- def prd cobindp : forall a b. CoMaybe(a) -> (CoMaybe(a) -> b) -> CoMaybe(b) :=
    -- cofun2fun MkNotp(cobind2);

def prd divTest : I64 -> CoMaybe(I64) := 
    \x => cocase {
            CoNothing => #ExitFailure,
            CoJust(k) => div x MkI64(21#I64) >> k
        };

def cmd main := cojoinp test >> CoJust(CoJust(case { MkI64(i) => #Print(i, #ExitSuccess) } ));
-- def cmd main2 := cobind >> CoJust(CoJust(case { MkI64(i) => #Print(i, #ExitSuccess) } ));

