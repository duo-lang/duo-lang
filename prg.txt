## Generic print consumer ##
cns print := mu* x.Print x;

## Boolean functions ##

prd ifthenelse := {- Ap(b,x,y)[k] => b >> {+ True => x >> k, False => y >> k +}-};
prd neg := {- Ap(b)[k] => b >> {+ True => False >> k, False => True >> k +} -};
prd and := {- Ap(x,y)[k] => ifthenelse >> Ap(x,y,x)[k] -};
prd or := {- Ap(x,y)[k] => ifthenelse >> Ap(x,x,y)[k] -};
prd nand := {- Ap(x,y)[k] => and >> Ap(x,y)[mu* z. neg >> Ap(z)[k]] -};
prd nor := {- Ap(x,y)[k] => or >> Ap(x,y)[mu* z. neg >> Ap(z)[k]] -};
prd impl := {- Ap(x,y)[k] => x >> {+ True => y >> k, False => True >> k +} -};

## basic functional stuff ##

prd id := {- Ap(x)[k] => x >> k -};
prd idAlt := \(x)[k] => x >> k;
prd curry := {- Ap(f)[k] => {- Ap(x)[k] => {-Ap(y)[k] => f >> Ap(x,y)[k]-} >> k-} >> k -};
prd uncurry := {- Ap(f)[k] => {- Ap(x,y)[k] => f >> Ap(x)[Ap(y)[k]] -} >> k-};
prd comp := {- Ap(f,g)[k] => {- Ap(x)[k] => g >> Ap(x)[mu* w. f >> Ap(w)[k]] -} >> k -};
prd twice := {- Ap(f)[k] => {- Ap(x)[k] => comp >> Ap(f,f)[Ap(x)[k]] -} >> k-};
prd thrice := {- Ap(f)[k] => {- Ap(x)[k] => comp >> Ap(f,f)[mu*g. comp >> Ap(g,f)[Ap(x)[k]]] -} >> k-};

## fixed point combinators ##

prd fix := {- Ap(f)[k] => {- Ap(x)[k] => f >> Ap({- Ap(v)[k] => x >> Ap(x)[Ap(v)[k]] -})[k] -} >> Ap({- Ap(x)[k] => f >> Ap({- Ap(v)[k] => x >> Ap(x)[Ap(v)[k]] -})[k] -})[k] -};
prd fixLazy := {- Ap(f)[k] => {- Ap(x)[k] => x >> Ap(x)[mu*xx. f >> Ap(xx)[k]] -} >> Ap({- Ap(x)[k] => x >> Ap(x)[mu*xx. f >> Ap(xx)[k]] -})[k] -};

## basic recursive functions ##

prd recZero := {- Ap(n)[k] => fix >> Ap({-Ap(alpha)[k] => {-Ap(n)[k] => n >> {+ Z => Z >> k, S(p) => alpha >> Ap(p)[k] +}-} >> k-})[Ap(n)[k]] -};
prd retItself := {- Ap(x)[k] => {- Ap(x)[k] => {- Ap(y)[k] => x >> Ap(x)[k] -} >> k -} >> Ap({- Ap(x)[k] => {- Ap(y)[k] => x >> Ap(x)[k] -} >> k -})[k] -};
prd omega := mu k. {- Ap(x)[k] => x >> Ap(x)[k] -} >> Ap({- Ap(x)[k] => x >> Ap(x)[k] -})[k];

## natural number arithmetic

prd succ := {- Ap(n)[k] => S(n) >> k -};
prd pred := {- Ap(n)[k] => n >> {+ S(m) => m >> k +} -};
prd add := {- Ap(n,m)[k] => fix >> Ap({- Ap(alpha)[k] => {- Ap(m)[k] => m >> {+ Z => n >> k, S(p) => alpha >> Ap(p)[mu* w. S(w) >> k] +} -} >> k -})[Ap(m)[k]] -};
prd mlt := {- Ap(n,m)[k] => fix >> Ap({- Ap(alpha)[k] => {- Ap(m)[k] => m >> {+ Z => Z >> k, S(p) => alpha >> Ap(p)[mu* w. add >> Ap(n,w)[k]] +} -} >> k -})[Ap(m)[k]] -};
prd exp := {- Ap(n,m)[k] => fix >> Ap({- Ap(alpha)[k] => {- Ap(m)[k] => m >> {+ Z => S(Z) >> k, S(p) => alpha >> Ap(p)[mu* w. mlt >> Ap(n,w)[k]] +} -} >> k -})[Ap(m)[k]] -};
prd sub := {- Ap(n,m)[k] => fix >> Ap({- Ap(alpha)[k] => {- Ap(m)[k] => m >> {+ Z => n >> k, S(p) => alpha >> Ap(p)[mu*w. pred >> Ap(w)[k]] +} -} >> k -})[Ap(m)[k]] -};
prd subSafe := {- Ap(n,m)[k] => fix >> Ap({- Ap(alpha)[k] => {- Ap(n)[k] => {- Ap(m)[k] => m >> {+ Z => n >> k, S(mp) => n >> {+ Z => n >> k, S(np) => alpha >> Ap(np)[Ap(mp)[k]] +} +} -} >> k -} >> k -})[Ap(n)[Ap(m)[k]]] -};
prd foldNat := {- Ap(n,x,f)[k] => fix >> Ap({- Ap(alpha)[k] => {- Ap(n)[k] => {- Ap(x)[k] => n >> {+ Z => x >> k, S(p) => f >> Ap(x)[mu*w. alpha >> Ap(p)[Ap(w)[k]]] +} -} >> k -} >> k -})[Ap(n)[Ap(x)[k]]] -};
prd foldNat1 := {- Ap(n,x,f)[k] => fix >> Ap({- Ap(alpha)[k] => {- Ap(n)[k] => {- Ap(x)[k] => n >> {+ S(m) => m >> {+ Z => f >> Ap(x)[k], S(p) => f >> Ap(x)[mu*w. alpha >> Ap(m)[Ap(w)[k]]] +} +} -} >> k -} >> k -})[Ap(n)[Ap(x)[k]]] -};

prd ltUnsafe := {- Ap(n,m)[k] => fix >> Ap({- Ap(alpha)[k] => {- Ap(n)[k] => {- Ap(m)[k] => n >> {+ Z => True >> k, S(np) => m >> {+ S(mp) => alpha >> Ap(np)[Ap(mp)[k]] +} +} -} >> k -} >> k -})[Ap(n)[Ap(m)[k]]] -};
prd ltSafe := {- Ap(n,m)[k] => fix >> Ap({- Ap(alpha)[k] => {- Ap(n)[k] => {- Ap(m)[k] => n >> {+ Z => True >> k, S(np) => m >> {+ Z => False >> k, S(mp) => alpha >> Ap(np)[Ap(mp)[k]] +} +} -} >> k -} >> k -})[Ap(n)[Ap(m)[k]]] -};
prd eqUnsafe := {- Ap(n,m)[k] => fix >> Ap({- Ap(alpha)[k] => {- Ap(n)[k] => {- Ap(m)[k] => n >> {+ Z => m >> {+ Z => True >> k +}, S(np) => m >> {+ S(mp) => alpha >> Ap(np)[Ap(mp)[k]] +} +} -} >> k -} >> k -})[Ap(n)[Ap(m)[k]]] -};
prd eqSafe := {- Ap(n,m)[k] => fix >> Ap({- Ap(alpha)[k] => {- Ap(n)[k] => {- Ap(m)[k] => n >> {+ Z => m >> {+ Z => True >> k, S(mp) => False >> k +}, S(np) => m >> {+ Z => False >> k, S(mp) => alpha >> Ap(np)[Ap(mp)[k]] +} +} -} >> k -} >> k -})[Ap(n)[Ap(m)[k]]] -};
prd times2 := {- Ap(n)[k] => fix >> Ap({- Ap(alpha)[k] => {- Ap(n)[k] => n >> {+ Z => Z >> k, S(m) => alpha >> Ap(m)[mu*w. S(S(w)) >> k] +} -} >> k -})[Ap(n)[k]] -};
prd times3 := {- Ap(n)[k] => fix >> Ap({- Ap(alpha)[k] => {- Ap(n)[k] => n >> {+ Z => Z >> k, S(m) => alpha >> Ap(m)[mu*w. S(S(S(w))) >> k] +} -} >> k -})[Ap(n)[k]] -};
prd times2or3 := {- Ap(b,n)[k] => b >> {+ True => times2 >> Ap(n)[k], False => times3 >> Ap(n)[k] +} -};
prd times2and3 := {- Ap(n)[k] => comp >> Ap(times2,times3)[Ap(n)[k]] -};
prd div2 := {- Ap(n)[k] => fix >> Ap({- Ap(alpha)[k] => {- Ap(n)[k] => n >> {+ Z => Z >> k, S(m) => m >> {+ S(p) => alpha >> Ap(p)[mu*w. S(w) >> k] +} +} -} >> k -})[Ap(n)[k]] -};
prd div3 := {- Ap(n)[k] => fix >> Ap({- Ap(alpha)[k] => {- Ap(n)[k] => n >> {+ Z => Z >> k, S(m) => m >> {+ S(p) => p >> {+ S(r) => alpha >> Ap(r)[mu*w. S(w) >> k] +} +} +} -} >> k -})[Ap(n)[k]] -};
prd div2or3 := {- Ap(b,n)[k] => b >> {+ True => div2 >> Ap(n)[k], False => div3 >> Ap(n)[k] +} -};
prd div2and3 := {- Ap(n)[k] => comp >> Ap(div2,div3)[Ap(n)[k]] -};

## pairs (data type)
prd fst := {- Ap(p)[k] => p >> {+ Pair(x,y) => x >> k +} -};
prd snd := {- Ap(p)[k] => p >> {+ Pair(x,y) => y >> k +} -};
prd bimapDat := {- Ap(f,g,p)[k] => p >> {+ Pair(x,y) => f >> Ap(x)[mu*fx. g >> Ap(y)[mu*gy. Pair(fx,gy) >> k]] +} -};

## pairs (codata type)
prd pair := {- Ap(x,y)[k] => {- Fst[k1] => x >> k1, Snd[k2] => y >> k2 -} >> k -};
prd bimapCodat := {- Ap(f,g,p)[k] => {- Fst[k1] => p >> Fst[mu*x. f >> Ap(x)[k1]], Snd[k2] => p >> Snd[mu*y. g >> Ap(y)[k2]] -} >> k -};

## lists (data type)
prd map := {- Ap(f,xs)[k] => fix >> Ap({- Ap(alpha)[k] => {- Ap(xs)[k] => xs >> {+ Nil => Nil >> k, Cons(p,ys) => alpha >> Ap(ys)[mu* w1. f >> Ap(p)[mu* w2. Cons(w2,w1) >> k]] +} -} >> k-})[Ap(xs)[k]] -};
prd head := {- Ap(xs)[k] => xs >> {+ Cons(x,xs) => x >> k +} -};
prd tail := {- Ap(xs)[k] => xs >> {+ Cons(x,xs) => xs >> k +} -};
prd null := {- Ap(xs)[k] => xs >> {+ Nil => True >> k, Cons(x,rest) => False >> k +} -};
prd append := {- Ap(xs,ys)[k] => fix >> Ap({- Ap(alpha)[k] => {- Ap(xs)[k] => xs >> {+ Nil => ys >> k, Cons(x,rest) => alpha >> Ap(rest)[mu*w. Cons(x,w) >> k] +} -} >> k -})[Ap(xs)[k]] -};
prd elemAt := {- Ap(xs,n)[k] => fix >> Ap({- Ap(alpha)[k] => {- Ap(xs)[k] => {- Ap(n)[k] => n >> {+ Z => head >> Ap(xs)[k], S(p) => tail >> Ap(xs)[mu*w. alpha >> Ap(w)[Ap(p)[k]]] +} -} >> k -} >> k -})[Ap(xs)[Ap(n)[k]]] -};
prd foldl := {- Ap(f,x,xs)[k] => fix >> Ap({- Ap(alpha)[k] => {- Ap(x)[k] => {- Ap(xs)[k] => xs >> {+ Nil => x >> k, Cons(y,ys) => f >> Ap(x,y)[mu*fxy.alpha >> Ap(fxy)[Ap(ys)[k]]] +} -} >> k -} >> k -})[Ap(x)[Ap(xs)[k]]] -};
prd reverse := {- Ap(xs)[k] => fix >> Ap({- Ap(alpha)[k] => {- Ap(xs)[k] => xs >> {+ Nil => Nil >> k, Cons(x,rest) => alpha >> Ap(rest)[mu*w. append >> Ap(w,Cons(x,Nil))[k]] +} -} >> k -})[Ap(xs)[k]] -};
prd length := {- Ap(xs)[k] => fix >> Ap({- Ap(alpha)[k] => {- Ap(xs)[k] => xs >> {+ Nil => Z >> k, Cons(x,rest) => alpha >> Ap(rest)[mu*w. S(w) >> k] +} -} >> k -})[Ap(xs)[k]] -};
prd filter := {- Ap(p,xs)[k] => fix >> Ap({- Ap(alpha)[k] => {- Ap(xs)[k] => xs >> {+ Nil => Nil >> k, Cons(x,rest) => p >> Ap(x)[{+ True => alpha >> Ap(rest)[mu*w. Cons(x,w) >> k], False => alpha >> Ap(rest)[k] +}] +} -} >> k -})[Ap(xs)[k]] -};


## lists (codata type)
prd consNeg := {- Ap(x,xs)[k] => {- Head[k] => x >> k, Tail[k] => xs >> k -} >> k -};
prd mapNeg := {- Ap(f,xs)[k] => fix >> Ap({- Ap(alpha)[k] => {- Ap(xs)[k] => {- Head[k] => xs >> Head[mu*w. f >> Ap(w)[k]], Tail[k] => xs >> Tail[mu*w. alpha >> Ap(w)[k]] -} >> k -} >> k -})[Ap(xs)[k]] -};
prd elemAtNeg := {- Ap(xs,n)[k] => fix >> Ap({- Ap(alpha)[k] => {- Ap(xs)[k] => {- Ap(n)[k] => n >> {+ Z => xs >> Head[k], S(m) => xs >> Tail[mu*ys. alpha >> Ap(ys)[Ap(m)[k]]] +} -} >> k -} >> k -})[Ap(xs)[Ap(n)[k]]] -};
prd repeat := {- Ap(x)[k] => fixLazy >> Ap({- Ap(alpha)[k] => {- Head[k] => x >> k, Tail[k] => alpha >> k -} >> k -})[k] -};

## misc interesting terms

prd doubleCycle := {- Ap(x) => fix >> Ap({- Ap(alpha)[k] => {- Ap(x) => x >> {+ X(x1) => x1 >> {+ X(x2) => alpha >> Ap(x2) +}, Y(y1) => y1 >> {+ Y(y2) => alpha >> Ap(y2) +} +} -} >> k -})[Ap(x)] -};
prd faultyEdgeTest := {- Ap(b,f) => b >> {+ True => f >> {+ X(x) => Done, Y(x) => Done +}, False => f >> {+X(x) => Done, Z(x)=>Done +} +} -};
prd oneortwo := {- Ap(b)[k] => b >> {+ True => S(Z) >> k, False => S(S(Z)) >> k +} -};
prd admissabilityTest := {- Ap(f)[k] => True >> {+ True => {- Ap(x)[k] => f >> Ap(x)[k] -} >> k, False => f >> k +}-};

prd implicationConstraintsTest1 := {- Ap(x) => x >> {+ A => Done, B => x >> {+ B => Done +} +} -};

prd parserTest := {- Ap(x)[x] => x >> x -};
prd parserTest2 := \(x)[x] => x >> x;
