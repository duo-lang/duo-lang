module Working;

-- prerequisites

data Nat {
    Z,
    S(Nat)
};

data Bool {
    True,
    False
};

-- the "classic" function application

codata Function : (-a: CBV, +b: CBV) -> CBV {
    Ap(a, return b)
};

type operator -> rightassoc at 0 := Function;

def rec prd add : Nat -> Nat -> Nat :=
    \n m => case n of { Z => m
                      , S(n) => S(add n m)};


def prd id : forall a. a -> a := cocase {
    Ap(x,*) => x
};

def prd plus1 : Nat -> Nat := cocase {
    Ap(x,*) => add x 1
};

-- defunctionalize

data Defun : (+a : CBV, -b: CBV) -> CBV {
    Id(a, return b),
    Plus1(Nat, return Nat)
};

def cns ap : forall a. Defun(a,a) := case {
    Id(x,*) => x,
    Plus1(x,*) => add x 1
};

def cmd main := Id(True,mu x. #Print(x, #ExitSuccess)) >> ap;
