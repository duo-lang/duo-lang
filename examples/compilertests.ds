-- These examples serve primarily as a testsuite for the compiler.
-- Do not expect the following examples to be sensible or understandable
import Function;
import Peano;
import Bool;
import Prelude;

-- Symmetric system:

def id1[*] : forall a. a -> a := cocase { Ap(x)[k] => x >> k };

def idPolyTwo[*] : forall a b. (a /\ b) -> (a \/ b) := cocase { Ap(x)[k] => x >> k };

def id[*] : Nat -> Nat := cocase { Ap(x)[k] => x >> k };

def idNominal[*] : Nat -> Nat := cocase { Ap(x)[k] => x >> k };

-- Asymmetric system:

def idPoly[*] : forall a. a -> a := cocase { Ap(x)[*] => x };

def idPolyTwo[*] : forall a b. (a /\ b) -> (a \/ b) := cocase { Ap(x)[*] => x };

def id[*] : Nat -> Nat := cocase { Ap(x)[*] => x };

destructor ApS(CBV)[CBV]: CBV;
destructor Ap2(CBV,CBV)[CBV] : CBV;
destructor Ap3(CBV,CBV,CBV)[CBV] : CBV;
constructor TT;
constructor FF;
constructor Succ(CBV);
constructor Zero;

-- Check subsumption for negative typeschemes
def subsumptionEx1(*) : < TT > := case { TT => ExitSuccess, FF => ExitSuccess};
def subsumptionEx2(*) : Nat := mu n. ExitSuccess; 



def fix[*] := cocase { ApS(f)[k] =>
             cocase { ApS(x)[k] => f >>
               ApS( cocase { ApS(v)[k] => x >> ApS(x)[ApS(v)[k]] })[k] } >>
                 ApS( cocase { ApS(x)[k] => f >>
                   ApS( cocase { ApS(v)[k] => x >> ApS(x)[ApS(v)[k]] })[k] })[k] };

def addNominal[*] := cocase { Ap2(n,m)[k] => fix >> ApS( cocase { ApS(alpha)[k] => cocase { ApS(m)[k] => m >> case { Z => n >> k, S(p) => alpha >> ApS(p)[mu w. S(w) >> k] }} >> k })[ApS(m)[k]] };
def mltNominal[*] := cocase { Ap2(n,m)[k] => fix >> ApS(cocase { ApS(alpha)[k] => cocase { ApS(m)[k] => m >> case { Z => Z >> k, S(p) => alpha >> ApS(p)[mu w. addNominal >> Ap2(n,w)[k]] } } >> k })[ApS(m)[k]]};

def ex1[*] : forall a. { ApS(a)[a] } := cocase { ApS(x)[k] => x >> k };

def ex2[*] : < Succ(< Zero >) > := Succ(Zero);

def ex3[*] : forall a. { Ap3(< TT , FF >, a, a)[a] } := cocase { Ap3(b,x,y)[k] => b >> case { TT => x >> k, FF => y >> k }};

def ex4[*] : forall a b. { Ap3(<TT,FF>, a, b)[a \/ b] } := cocase { Ap3(b,x,y)[k] => b >> case { TT => x >> k, FF => y >> k }};

def ex5[*] :  forall a b. { ApS({ ApS(a \/ b)[b] })[{ ApS(a)[b] }] } := cocase { ApS(f)[k] => (cocase { ApS(x)[k] => f >> ApS(x)[mu y. f >> ApS(y)[k]]}) >> k};

def ex6[*] : { ApS(Bool)[Bool] } := cocase { ApS(x)[k] => x >> case { True => False >> k, False => True >> k }};

def ex7[*] : { ApS(Bool)[(Bool \/ Nat)] } := cocase { ApS(x)[k] => x >> case { True => False >> k, False => Z >> k }};

def ex8[*] : { ApS(Bool)[(Nat \/ Bool)] } := cocase { ApS(x)[k] => x >> case { True => False >> k, False => Z >> k }};

def ex9[*] : { Ap2(Nat,Nat)[Nat] } := cocase { Ap2(n,m)[k] => fix >> ApS( cocase { ApS(alpha)[k] => cocase { ApS(m)[k] => m >> case { Z => n >> k, S(p) => alpha >> ApS(p)[mu w. S(w) >> k] }} >> k })[ApS(m)[k]] };

def ex10[*] : forall t0. { Ap2((t0 /\ Nat),Nat)[(t0 \/ Nat)] } := cocase { Ap2(n,m)[k] => fix >> ApS(cocase { ApS(alpha)[k] => cocase { ApS(m)[k] => m >> case { Z => Z >> k, S(p) => alpha >> ApS(p)[mu w. addNominal >> Ap2(n,w)[k]] } } >> k })[ApS(m)[k]]};

def ex11[*] : forall t0. { Ap2((t0 /\ Nat),Nat)[(t0 \/ Nat)] } := cocase { Ap2(n,m)[k] => fix >> ApS(cocase { ApS(alpha)[k] => cocase { ApS(m)[k] => m >> case { Z => S(Z) >> k, S(p) => alpha >> ApS(p)[mu w. mltNominal >> Ap2(n,w)[k]] } } >> k })[ApS(m)[k]] };

def ex12[*] : forall t0. { Ap2((t0 /\ Nat),Nat)[(t0 \/ Nat)] } := cocase { Ap2(n,m)[k] => fix >> ApS(cocase { ApS(alpha)[k] => cocase { ApS(n)[k] => cocase { ApS(m)[k] => m >> case { Z => n >> k, S(mp) => n >> case { Z => n >> k, S(np) => alpha >> ApS(np)[ApS(mp)[k]] }}} >> k } >> k })[ApS(n)[ApS(m)[k]]]};
