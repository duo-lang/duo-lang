module Transformation;

import Data.Peano;
import Data.Maybe;
import Data.Bool;

data List : CBV {
    Nil,
    Cons(Nat,List)
};



def rec prd index : List -> Nat -> Maybe(Nat) :=
    \l n => case l of {
        Nil => Nothing,
        Cons(head, tail) => case n of {
            Z => Just(head),
            S(num) => index tail num
        }
    };



codata CoList : CBV {
    Index(Nat, return Maybe(Nat))
};

def prd nil : CoList := cocase {
    Index(n,*) => Nothing
};

def prd oneElemList : ((Nat:CBV) -> ((CoList:CBV) -> (CoList:CBV))) := cocase {
   Ap(x1,k1) => 
      (cocase {
         Ap(x2,k2) => 
            (cocase {
               Index(x3,k3) => 
                  (mu k4.((x3) >> case {Z() => (Just( x1 )) >> k4, S(x4) => (Just( 0 )) >> k4}))
                  >>
                  k3})
            >>
            k2})
      >>
      k1};

def rec prd cons : Nat -> CoList -> CoList := \head tail => cocase {
    Index(n,*) => case n of {
        Z => Just(head),
        S(num) => tail.Index(num,*)
    }
};

--examples
def prd listWithData := Cons(1, Cons(2, Cons(3,Nil)));
def prd listWithCodata := cons 1 (cons 2 (cons 3 nil));