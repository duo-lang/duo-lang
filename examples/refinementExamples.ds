set refined;

# Examples for testing type decl translation
data Bool : Type CBV { True, False }; # Boolean values
data Nat : Type CBV { Z, S(Nat) }; # Natural numbers

data Even : Type CBV { Ze, Se(Odd) }; # Dual mutual recursion
data Odd  : Type CBV { So(Even) };

data X1 : Type CBV { A, B(X2), C(X3) }; # Multiple mutual recursion
data X2 : Type CBV { D(X3) };
data X3 : Type CBV { E(X1,X2) };

codata Tuple : Type CBV { Left, Right };
codata Fun : Type CBV { ApNN(Nat)[Nat], ApBB(Bool)[Bool], ApNB(Nat)[Bool] };

# Structural and refinement (co)data as well as refinements of different 
# nominal types should not mix
prd ex1 := match True with { True => S(Z), False => 'H };

prd ex2 := match True with { True => S(Z), False => True };

# Data construction
prd oneS := S(Z);
prd threeS := S(S(S(Z)));

prd oneA := S(Z);
prd threeA := S(S(S(Z)));

# Incomplete pattern and copattern matches
cns foo := match { True => Print('T) };

prd isSuccA := comatch { ApNB(n) => match n with { 
                 S(m) => True
               }};

prd isSuccS := comatch { ApNB(n)[k] => n >> match {
                 S(m) => True >> k
               }};

prd isOneA := comatch { ApNB(n) => match n with {
                S(m) => match m with {
                  Z() => True
                }
              }};

prd isOneS := comatch { ApNB(n)[k] => n >> match {
                S(m) => m >> match {
                  Z() => True >> k
                }
              }};

prd isTwoA := comatch { ApNB(n) => match n with {
               S(p) => match p with {
                 S(q) => match q with {
                   Z() => True
                 }
               }
             }};

prd isTwoS := comatch { ApNB(n)[k] => n >> match {
                S(p) => p >> match {
                  S(q) => q >> match {
                    Z() => True >> k
                  }
                }
              }};

prd notA := comatch { ApBB(b) => match b with {
              True => False,
              False => True
            }};

prd notS := comatch { ApBB(b)[k] => b >> match {
              True => False >> k,
              False => True >> k
            }};

# Codata examples
prd pairA := comatch {
               Left  => True,
               Right => False
             };

prd pairS := comatch {
              Left[k]  => True >> k,
              Right[k] => False >> k
            };

prd pairLeftA := comatch {
                  Left => True
                };

prd pairLeftS := comatch {
                   Left[k] => True >> k
                 };

prd idA := comatch {
            ApNN(n) => n,
            ApBB(b) => b
          };

prd idS := comatch {
            ApNN(n)[k] => n >> k,
            ApBB(b)[k] => b >> k
          };

prd succA := comatch { ApNN(n) => S(n) };

prd succS := comatch { ApNN(n)[k] => S(n) >> k };
