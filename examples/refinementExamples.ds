set refined;

# Examples for testing type decl translation
data Bool { True, False }; # Boolean values
data Nat  { Z, S(Nat) }; # Natural numbers

data Even { Ze, Se(Odd) }; # Dual mutual recursion
data Odd  { So(Even) };

data X1 { A, B(X2), C(X3) }; # Multiple mutual recursion
data X2 { D(X3) };
data X3 { E(X1,X2) };

# Structural and refinement (co)data as well as refinements of different 
# nominal types should not mix
def ex1 := match True with { True => S(Z), False => 'H };

def ex2 := match True with { True => S(Z), False => True };

prd oneS := S(Z);
prd threeS := S(S(S(Z)));

def oneA := S(Z);
def threeA := S(S(S(Z)));

# Incomplete pattern matches, level 1
cns foo := match { True => Print('T) };

def isSuccA := comatch { 'Ap(n) => match n with { 
                 S(m) => True
               }};

prd isSuccS := comatch { 'Ap(n)[k] => n >> match {
                 S(m) => True >> k
               }};

# Incomplete pattern match, level 2
# Case arg m is inferred as {{ Nat :>> < 'Z | 'S(Nat) > }},
# therefore case S() is recognized as missing in pattern match
def isOneA := comatch { 'Ap(n) => match n with {
                S(m) => match m with {
                  Z() => True
                }
              }};

prd isOneS := comatch { 'Ap(n)[k] => n >> match {
                S(m) => m >> match {
                  Z() => True >> k
                }
              }};

def isTwoA := comatch { 'Ap(n) => match n with {
               S(p) => match p with {
                 S(q) => match q with {
                   Z() => True
                 }
               }
             }};