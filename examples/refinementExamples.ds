# Examples for testing type decl translation
refinement data Bool : CBV { True, False }; # Boolean values
refinement data Nat : CBV { Z, S(Nat) }; # Natural numbers

#refinement data Even : CBV { Ze, Se(Odd) }; # Dual mutual recursion
#refinement data Odd  : CBV { So(Even) };

#refinement data X1 : CBV { A, B(X2), C(X3) }; # Multiple mutual recursion
#refinement data X2 : CBV { D(X3) };
#refinement data X3 : CBV { E(X1,X2) };

refinement codata Tuple : CBV { Left[Bool], Right[Bool] };
refinement codata Fun : CBV { ApNN(Nat)[Nat], ApBB(Bool)[Bool], ApNB(Nat)[Bool] };

constructor H : CBV;
# Structural and refinement (co)data as well as refinements of different
# nominal types should not mix
prd ex1 := case True of { True => S(Z), False => H };

prd ex2 := case True of { True => S(Z), False => True };

# Data construction
prd oneS : <Nat | S(<Nat | Z >) > := S(Z);
prd threeS := S(S(S(Z)));

prd oneA := S(Z);
prd threeA := S(S(S(Z)));

constructor T : CBV;
# Incomplete pattern and copattern matches
cns foo : < Bool | True > := match { True => Print(T); Done };

prd isSuccA := cocase { ApNB(n)[*] => case n of {
                 S(m) => True
               }};

prd isSuccS := cocase { ApNB(n)[k] => n >> match {
                 S(m) => True >> k
               }};

prd isOneA := cocase { ApNB(n)[*] => case n of {
                S(m) => case m of {
                  Z() => True
                }
              }};

prd isOneS := cocase { ApNB(n)[k] => n >> match {
                S(m) => m >> match {
                  Z() => True >> k
                }
              }};

prd isTwoA := cocase { ApNB(n)[*] => case n of {
               S(p) => case p of {
                 S(q) => case q of {
                   Z() => True
                 }
               }
             }};

prd isTwoS := cocase { ApNB(n)[k] => n >> match {
                S(p) => p >> match {
                  S(q) => q >> match {
                    Z() => True >> k
                  }
                }
              }};

prd notA := cocase { ApBB(b)[*] => case b of {
              True => False,
              False => True
            }};

prd notS := cocase { ApBB(b)[k] => b >> match {
              True => False >> k,
              False => True >> k
            }};

# Codata examples
prd pairA : { Tuple | Left[<Bool | True >], Right[<Bool | False>]}:= cocase {
               Left[*]  => True,
               Right[*] => False
             };

prd pairS := cocase {
              Left[k]  => True >> k,
              Right[k] => False >> k
            };

prd pairLeftA := cocase {
                  Left[*] => True
                };

prd pairLeftS := cocase {
                   Left[k] => True >> k
                 };

prd idA := cocase {
            ApNN(n)[*] => n,
            ApBB(b)[*] => b
          };

prd idS := cocase {
            ApNN(n)[k] => n >> k,
            ApBB(b)[k] => b >> k
          };

prd succA := cocase { ApNN(n)[*] => S(n) };

prd succS := cocase { ApNN(n)[k] => S(n) >> k };

prd rec natIdA := cocase { ApNN(n)[*] => case n of {
            Z    => Z,
            S(m) => S(natIdA.ApNN(m)[*])
}};

prd rec isEvenA := cocase { ApNB(n)[*] => case n of {
  Z => True,
  S(m) => case m of {
    S(p) => isEvenA.ApNB(p)[*]
}}};
