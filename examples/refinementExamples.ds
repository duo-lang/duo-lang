import Prelude;
set refined;

# Examples for testing type decl translation
data Nat  { Z, S(Nat) }; # Natural numbers

data Even { Z, Se(Odd) }; # Dual mutual recursion
data Odd  { So(Even) };

data X1 { A, B(X2), C(X3) }; # Multiple mutual recursion
data X2 { D(X3) };
data X3 { E(X1,X2) };


# def foo := S(Z);

# Incomplete pattern matches, level 1
cns foo := match { True => Print('T) };

def isSucc := comatch { 'Ap(n) => match n with { 
             S(m) => True
           }};

# Incomplete pattern match, level 2
# Case arg m is inferred as {{ Nat :>> < 'Z | 'S(Nat) > }},
# therefore case S() is recognized as missing in pattern match
# def isOneA := comatch { 'Ap(n) => match n with {
#                 S(m) => match m with {
#                   Z() => True
#                 }
#               }};

# def isTwo := comatch { 'Ap(n) => match n with {
#                S(p) => match p with {
#                  S(q) => match q with {
#                    Z() => True
#                  }
#                }
#              }};