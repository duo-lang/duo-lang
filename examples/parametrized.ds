import Prelude;

data List(+a : CBV) : CBV {
    Nil,
    Cons(a, List(a))
};

data Rose(+a : CBV) : CBN {
    Leaf(a),
    Node(List(Rose(a)))
};

data Fun(+b : CBV, -a : CBV) : CBN {
    Ap(a)[b]
};

constructor A : CBV;
constructor B : CBV;

prd l1 : List(Bool \/ Nat) := Cons(1, Cons(True, Nil));
prd l2 : List(<A | B>) := Cons(A, Cons(B, Nil));
prd l3 : List(Nat) := Cons(1, Cons(2, Cons(3, Nil)));
prd r1 : Rose(Nat) := Node(Cons(Leaf(1), Cons(Leaf(1), Nil)));
prd id : forall a. Fun(a, a) := match {
    Ap(x)[k] => x >> k
};
prd x := id.Ap(1)[*];
prd succ := match {
    Ap(x)[k] => S(x) >> k
};

prd rec map : forall a b. Fun(Fun(List(b), List(a)), Fun(b, a)) := match {
    Ap(g)[j] => match {
        Ap(xs)[k] => case xs of {
            Nil => Nil,
            Cons(y, ys) => Cons(g.Ap(y)[*], map.Ap(ys)[*])
        } >> k
    } >> j
};

prd xs := (map.Ap(succ)[*]).Ap(l3)[*];
cmd main := Print(xs); Done;
