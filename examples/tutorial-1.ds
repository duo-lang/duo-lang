# ##################
# Tutorial Part 1
# ##################

# Welcome to the first part of this tutorial and short tour of the features of DualSub.
#
# In order to try out the examples, please start a REPL session with `stack run dualsub`,
# and enter `:load tutorial-1.txt` to start following along.

# ####################################
# 1.1 Data Types and Pattern matching.
# ####################################

# DualSub supports standard algebraic data types, which can be declared with the following
# syntax:

data Bool { True, False };
data Nat { Zero, Succ(Nat) };

# Note that type and value constructors have to start with an uppercase letter, and how arguments
# to constructors are indicated in parentheses.

# We can define toplevel values using the following syntax, where the names of defined terms have
# to start with a lowercase letter.

def true := True;
def two := Succ(Succ(Zero));

# We also provide some syntactic sugar for (Peano) natural numbers, so that `two` can
# alternatively be written in the following way.

def twoSugared := 2;

# We now want to check the inferred types of our declared terms. In order to do that you can
# enter the following command in the REPL:
#
# > :type two
# --> Nat

# Datatypes would be quite useless if you couldn't also destruct them via pattern matching.
# A convoluted way to define the number two is to define it as the predecessor of 3:

def convolutedTwo := match 3 with { Zero => Zero, Succ(x) => x };

# Pattern matches on the constructors of a declared datatype have to be exhaustive,
# otherwise an error is reported.

# In order to evaluate `convolutedTwo` to its canonical form, just enter it in the REPL.
#
# > convolutedTwo
# --> 2

# The terms are evaluated using a call-by-value evaluation strategy.
# Note that we do not support nested patterns at the moment.

# ########################################
# 1.2 Codata Types and Copattern matching.
# ########################################

# You now probably want to define some functions, but DualSub does not have a builtin function type.
# Instead, you can define one yourself, using codata types, which are dual to data types.
# So let's define a (monomorphic) function type, the type of functions from Nat to Bool.

codata Fun { Ap(Nat)[Bool] };

# We call `Ap` (short for "apply) a destructor of the codata type Fun. In parentheses we indicate
# the arguments of the destructor, and in square brackets we indicate the return type.
# For the moment, we restrict ourselves to one return type, but will come back to the general situation
# at a later point.
#
# We can use a copattern match (or "comatch" for short) to construct a term of this codata type.
# For example, we can define the functions which return constant True or False:

def constTrue := comatch { Ap(x) => True };
def constFalse := comatch { Ap(x) => False };

# or, we can combine a copattern match with a pattern match to implement the `isZero` function:

def isZero := comatch { Ap(x) => match x with { Zero => True, Succ(x) => False } };

# We can call a function which is declared in this way by using its destructor on it.
# For example, in order to check whether 5 is zero, we can write:

# def isFiveZero := isZero.Ap(5);

# Here is how this syntax corresponds to the more usual syntax for lambda abstractions in, e.g. Haskell.
#
#    Haskell:                DualSub:
#
#    \x -> t          <->    comatch { Ap(x) => t }
#    f t              <->    f.Ap(t)
#
# Since functions are so ubiquitious, it is likely we are going to add some additional syntactic sugar
# for them in the future.

# All toplevel declarations are defined by mutual recursion, so it is possible to define a
# recursive function like `isEven`:

def isEven := comatch { Ap(x) => match x with
       { Zero => True
       , Succ(x) => isOdd.Ap(x) }};

def isOdd := comatch { Ap(x) => match x with
       { Zero => False
       , Succ(x) => isEven.Ap(x) }};

# The focus of DualSub is on the exploration of dualities in programming language design, so we want to
# provide a minimal set of different kinds of types in the language.
# DualSub provides four different kinds of types: nominal and structural data types, and nominal and
# structural codata types.
#
#    |-------------|------------------------------|---------------------|
#    |             |       Nominal                |        Structural   |
#    |-------------|------------------------------|---------------------|
#    |   Data      | data Nat { Zero, Succ(Nat) } |      (Part 2)       |
#    |-------------|------------------------------|---------------------|
#    |  Codata     | codata Fun { Ap(Nat)[Bool] } |      (Part 2)       |
#    |-------------|------------------------------|---------------------|
#
# In this part we have seen nominal data and codata types, in the next part of the tutorial we will introduce
# structural data and codata types.

