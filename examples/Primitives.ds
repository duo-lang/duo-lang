import Function;

data I64 : CBV {
    MkI64(#I64)
};

def add[*] : I64 -> I64 -> I64 := \x => \y =>
    case x of {
        MkI64(x) => case y of {
            MkI64(y) => mu k. Add#I64(x, y)[mu z. MkI64(z) >> k]
        }
    };

def sub[*] : I64 -> I64 -> I64 := \x => \y =>
    case x of {
        MkI64(x) => case y of {
            MkI64(y) => mu k. Sub#I64(x, y)[mu z. MkI64(z) >> k]
        }
    };

def mul[*] : I64 -> I64 -> I64 := \x => \y =>
    case x of {
        MkI64(x) => case y of {
            MkI64(y) => mu k. Mul#I64(x, y)[mu z. MkI64(z) >> k]
        }
    };

def div[*] : I64 -> I64 -> I64 := \x => \y =>
    case x of {
        MkI64(x) => case y of {
            MkI64(y) => mu k. Div#I64(x, y)[mu z. MkI64(z) >> k]
        }
    };

def mod[*] : I64 -> I64 -> I64 := \x => \y =>
    case x of {
        MkI64(x) => case y of {
            MkI64(y) => mu k. Mod#I64(x, y)[mu z. MkI64(z) >> k]
        }
    };

data F64 : CBV {
    MkF64(#F64)
};

def addf[*] : F64 -> F64 -> F64 := \x => \y =>
    case x of {
        MkF64(x) => case y of {
            MkF64(y) => mu k. Add#F64(x, y)[mu z. MkF64(z) >> k]
        }
    };

def subf[*] : F64 -> F64 -> F64 := \x => \y =>
    case x of {
        MkF64(x) => case y of {
            MkF64(y) => mu k. Sub#F64(x, y)[mu z. MkF64(z) >> k]
        }
    };

def mulf[*] : F64 -> F64 -> F64 := \x => \y =>
    case x of {
        MkF64(x) => case y of {
            MkF64(y) => mu k. Mul#F64(x, y)[mu z. MkF64(z) >> k]
        }
    };

def divf[*] : F64 -> F64 -> F64 := \x => \y =>
    case x of {
        MkF64(x) => case y of {
            MkF64(y) => mu k. Div#F64(x, y)[mu z. MkF64(z) >> k]
        }
    };

def x[*] := MkI64(7#I64);
def y[*] := MkI64(2#I64);

def xf[*] := MkF64(7.0#F64);
def yf[*] := MkF64(2.0#F64);

def main :=
    Print(add x y);
    Print(sub x y);
    Print(div x y);
    Print(mul x y);
    Print(mod x y);
    Done;

def mainf :=
    Print(addf xf yf);
    Print(subf xf yf);
    Print(divf xf yf);
    Print(mulf xf yf);
    Done;
