import Prelude;


codata Par : Type CBN { MkPar[List,Unit]};

data List : Type CBV { Nil, Cons(Nat,List) };

# Implementation is not important, since I only want to do typechecking.
prd rec f : Unit -> Par := f;
prd rec g : Unit -> Par := g;
prd rec h : Unit -> Par := h;

prd compose := \x => cocase { MkPar[err,*] =>
                                (h (g ((f x).MkPar[err,*]).MkPar[err,*])).MkPar[err,*]
                            };

prd rec filterHelper := \p l => case l of { 
    Nil => comatch {
        MkPar[k1,k2] => Unit >> k2
    },
    Cons(x,xs) => case p x of {
        True => 
            comatch {
                MkPar[k1,k2] =>
                    filterHelper p xs >> MkPar[mu ys. Cons(x,ys) >> k1, k2]
            },
        False => 
            comatch {
                MkPar[k1,k2] =>
                    filterHelper p xs >> MkPar[k1, mu y. xs >> k1]
            }
    }
};

prd filter  := \p l => mu k. filterHelper p l >> MkPar[k, mu y. l >> k];
prd filter2 := \p l => mu k. (filterHelper p l).MkPar[k,*] >> mu y. l >> k;

