import Function;
import Cofunction;
--------------------------------------------------------------------------------------------
-- Disjunction and its unit as a data type.
--
-- Disjunction, if defined as a datatype, consists of two constructors representing the two
-- alternative ways that  a OR b can be proved. This type corresponds to the "Either" type in
-- Haskell or the "Result" type in Rust.
--------------------------------------------------------------------------------------------

-- | Disjunction as a data type.
data Plus : (+a : CBV, +b : CBV) -> CBV {
    Left(a),
    Right(b)
}; 

type operator ⊕ leftassoc at 3 := Plus;

-- | The empty type as a data type.
data Void {};

-- TODO: Allow this to typecheck.
-- def prd absurd : Void -> Bot :=
--  \x => case x of {};

-- | Curried version of the Left constructor.
def prd left : forall a. a -> Plus(a,Bot) :=
  \x => Left(x);

-- | Curried version of the Right constructor.
def prd right : forall a. a -> Plus(Bot,a) :=
  \x => Right(x);

-- Deconstruct Plus by providing two functions.
def prd plusElim : forall a b c. (a -> c) -> (b -> c) -> Plus(a,b) -> c :=
  \f g e => case e of { Left(x) => f x
                      , Right(y) => g y
                      };


--------------------------------------------------------------------------------------------
-- Conjunction and its unit as a data type.
--
-- Conjunction, if defined as a datatype, is a type defined by the pairing constructor
-- which takes both elements of the pair.
--------------------------------------------------------------------------------------------

-- | Conjunction as a data type.
data Tensor : (+a : CBV, +b : CBV) -> CBV {
    MkTensor(a, b)
};

type operator ⊗ leftassoc at 5 := Tensor;

-- | The singleton type as a data type.
data Unit { MkUnit };

-- | First projection on Tensor.
def prd fst : forall a. Tensor(a,Top) -> a :=
  \p => case p of { MkTensor(x,y) => x};

-- | Second projection on Tensor
def prd snd : forall a. Tensor(Top,a) -> a :=
  \p => case p of { MkTensor(x,y) => y};

--------------------------------------------------------------------------------------------
-- Conjunction and its unit as a codata type.
--
-- Conjunction is defined as a codata type by specifying two destructors, the projection
-- on the first and second element.
--------------------------------------------------------------------------------------------

-- | Conjunction defined as a codata type.
codata With : (+a : CBV, +b : CBV) -> CBN {
    Proj1(return a),
    Proj2(return b)
};

type operator & leftassoc at 5 := With;

-- | The singleton type defined as a codata type.
codata UnitN {};

--def cns in1 : forall a b. a -> a & b := 
--  cocase {Ap(x,k) => };

-- TODO: Allow this to typecheck
-- def prd mkUnitN : UnitN :=
--   cocase {};

-- Curried pairing operation defined for With.
def prd pair : forall a b. a -> b -> a & b :=
  \x y => cocase { Proj1(*) => x
                 , Proj2(*) => y
                 };

-- | Curried projection on the first element.
def prd proj1 : forall a. a & Top -> a :=
  \x => x.Proj1(*);

-- | Curried projection on the second element.
def prd proj2 : forall a. Top & a -> a :=
  \x => x.Proj2(*);

--------------------------------------------------------------------------------------------
-- Disjunction and its unit as a codata type.
--
--
--------------------------------------------------------------------------------------------


-- | Disjunction as a codata type.
codata Par : (+a : CBV, +b : CBV) -> CBN {
    MkPar(return a, return b)
};

-- | The empty type as a codata type.
codata VoidN : CBV { MkVoidN };

type operator ⅋ leftassoc at 3 := Par;

-- | Injection into the right element of Par.
def prd unit : forall a. a -> Bot ⅋ a :=
  \x => cocase { MkPar(kerr,*) => x };

-- | Injection into the left element of Par.
def prd throw : forall a. a -> a ⅋ Bot :=
  \x => cocase { MkPar(*,kres) => x };

--------------------------------------------------------------------------------------------
-- Negation as a data type
--
--
--------------------------------------------------------------------------------------------

-- positive negation
-- not sure whether a should be CBV or CBN...
data Notp : (-a : CBV) -> CBV {
  MkNotp(return a)
}; 

def prd handle1 : forall a b. a ⅋ b -> Notp(a) -> b := 
  \f e => mu x. e >> case { MkNotp(k2) => f >> MkPar(k2,x)}; 

def prd handle2 : forall a b. a ⅋ b -> Notp(b) -> a := 
  \f e => mu x. e >> case { MkNotp(k2) => f >> MkPar(x,k2)}; 

-- negative negation

codata Notn: (-a : CBN) -> CBN {
  MkNotn(a)
};

-- De Morgan Dualities

def prd demorgan1 : forall p q. Notp(p ⊕ q) -> Notn(p) & Notn(q) := \x =>
   cocase {   Proj1(k) =>  x >> case { MkNotp(k2) => cocase { MkNotn(y) => Left(y)  >> k2 } >> k },
              Proj2(k) =>  x >> case { MkNotp(k2) => cocase { MkNotn(y) => Right(y) >> k2 } >> k }  };

def prd demorgan2 : forall p q. Notn(p) & Notn(q) -> Notp(p ⊕ q) := \x =>
   MkNotp(case { 
    Left(y)  => x >> Proj1(MkNotn(y)),
    Right(y) => x >> Proj2(MkNotn(y))
    });

def prd demorgan3 : forall p q. Notp(p) ⊕ Notp(q) -> Notn(p & q) := \x =>
  case x of {
    Left(y)  => cocase { MkNotn(z) => y >> case { MkNotp(k) => z >> Proj1(k)} },
    Right(y) => cocase { MkNotn(z) => y >> case { MkNotp(k) => z >> Proj2(k)} }
  };

-- this is the duality that does not hold intuitionistically 
-- this can be seen by the twofold occurence of k
def prd demorgan4 : forall p q. Notn(p & q) -> Notp(p) ⊕ Notp(q) := cocase { Ap(x,k) => 
  x >> MkNotn(cocase { Proj1(k2) => Left( MkNotp(k2)) >> k,
                       Proj2(k2) => Right(MkNotp(k2)) >> k})
};

def cns codemorgan1 : forall p q. Notn(p & q) -<  Notp(p) ⊕ Notp(q)  := \cox =< case {
   Left(x1)  => cocase { MkNotn(x2) => x1 >> case { MkNotp(k1) => x2 >> Proj1( k1 )}}  >> cox,
   Right(x3) => cocase { MkNotn(x4) => x3 >> case { MkNotp(k2) => x4 >> Proj2( k2 )}}  >> cox };

-- todo: codemorgan 2-4

def prd demorgan5 : forall p q. Notn(p ⅋ q) -> Notp(p) ⊗ Notp(q) := cocase { Ap(x,k) =>
 x >> MkNotn(cocase { MkPar(kpc,kqc) => MkTensor(MkNotp(kpc),MkNotp(kqc)) >> k }) };

def cns codemorgan5 : forall p q.  Notp( p ⊗ q  ) -<  Notn( p ) ⅋  Notn( q )  := case {
   CoAp(k1,x1) =>  (MkNotp( case {MkTensor(x2,x3) => x1 >> MkPar(MkNotn(x2),MkNotn(x3))})) >> k1}; 

--def prd demorgan6 : forall p q. Notp(p) ⊗ Notp(q) -> Notn(p ⅋ q) := ...
--def prd demorgan7 : forall p q. Notn(p ⊗ q) -> Notp(p) ⅋ Notp(q) :=
--def prd demorgan8 : forall p q. Notp(p) ⅋ Notp(q) -> Notn(p ⊗ q) := ...

-- todo : codemorgan 6-8  

def prd doublenegelim : forall p. Notp(Notp(p)) -> p := 
  cocase { Ap(x,k) => x >> case { MkNotp(ka) => MkNotp(k) >> ka }} ;

def cns codoublenegelim : forall p.  Notn( Notn( p ) ) -< p  := 
  case { CoAp(k1,x1) => cocase {MkNotn(x2) => x2 >> MkNotn( x1 )} >> k1};

