import Function;

-- | Positive Disjunction and its Unit
data Plus : (+a : CBV, +b : CBV) -> CBV {
    Left(a),
    Right(b)
}; 



data Void {};

-- | Positive Conjunction and its Unit
data Tensor : (+a : CBV, +b : CBV) -> CBV {
    MkTensor(a, b)
};

def fst[*] := \p => case p of { MkTensor(x,y) => x};
def snd[*] := \p => case p of { MkTensor(x,y) => y};

data Unit { MkUnit };

-- | Negative Conjunction and its Unit
codata With : (+a : CBV, +b : CBV) -> CBN {
    Proj1[a],
    Proj2[a]
};

type operator & leftassoc at 5 := With;

def pair[*] := \x y => cocase { Proj1[*] => x, Proj2[*] => y};

codata UnitN {};

-- | Negative Disjunction and its Unit
codata Par : (+a : CBV, +b : CBV) -> CBN {
    MkPar[a,b]
};

type operator ⅋ leftassoc at 3 := Par;

def return[*] : forall a. a -> Bot ⅋ a :=
  \x => cocase { MkPar[err,*] => x };

def throw[*] : forall a. a -> a ⅋ Bot :=
  \x => cocase { MkPar[*,res] => x };

codata VoidN : CBV { MkVoidN };

-- positive negation
-- not sure whether a should be CBV or CBN...
data Not : (-a : CBV) -> CBV {
  MkNot[a]
}; 

def handle1[*] : forall a b. a ⅋ b -> Not(a) -> b := 
  \f e => mu x. e >> case { MkNot[e2] => f >> MkPar[e2,x]}; 

def handle2[*] : forall a b. a ⅋ b -> Not(b) -> a := 
  \f e => mu x. e >> case { MkNot[e2] => f >> MkPar[x,e2]}; 