import Function;

-- | Positive Disjunction and its Unit
data Plus : (+a : CBV, +b : CBV) -> CBV {
    Left(a),
    Right(b)
}; 



data Void {};

-- | Positive Conjunction and its Unit
data Tensor : (+a : CBV, +b : CBV) -> CBV {
    MkTensor(a, b)
};

def prd fst := \p => case p of { MkTensor(x,y) => x};
def prd snd := \p => case p of { MkTensor(x,y) => y};

data Unit { MkUnit };

-- | Negative Conjunction and its Unit
codata With : (+a : CBV, +b : CBV) -> CBN {
    Proj1(return a),
    Proj2(return a)
};

type operator & leftassoc at 5 := With;

def prd pair := \x y => cocase { Proj1(*) => x, Proj2(*) => y};

codata UnitN {};

-- | Negative Disjunction and its Unit
codata Par : (+a : CBV, +b : CBV) -> CBN {
    MkPar(return a, return b)
};

type operator ⅋ leftassoc at 3 := Par;

def prd unit : forall a. a -> Bot ⅋ a :=
  \x => cocase { MkPar(err,*) => x };

def prd throw : forall a. a -> a ⅋ Bot :=
  \x => cocase { MkPar(*,res) => x };

codata VoidN : CBV { MkVoidN };

-- positive negation
-- not sure whether a should be CBV or CBN...
data Not : (-a : CBV) -> CBV {
  MkNot(return a)
}; 

def prd handle1 : forall a b. a ⅋ b -> Not(a) -> b := 
  \f e => mu x. e >> case { MkNot(e2) => f >> MkPar(e2,x)}; 

def prd handle2 : forall a b. a ⅋ b -> Not(b) -> a := 
  \f e => mu x. e >> case { MkNot(e2) => f >> MkPar(x,e2)}; 