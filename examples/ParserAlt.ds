import Bool;
import Function;
import List;
import Peano;
import Prelude;
import Cofunction;
import LinearLogic;

-- a backtracking parser combinator library

-- Alternative version: Formulate parser using fancy
-- cofunction and par types:

codata Parser :  CBN {
    Parse(List(Nat), return (Unit â…‹ (Unit -< List(Nat) )) )
}; 


def prd lit : Nat -> Parser := \n => cocase {
    Parse(xs,m) => xs >> case {
        Nil =>  throw MkUnit >> m,
        Cons(y, ys) => nateq y n >> case {
            True => unit CoAp(ys,mu z.throw z >> m) >> m,
            False => throw MkUnit >> m
        }            
    } 
} ; 

def prd success : Parser := cocase {
    Parse(xs,m) => unit CoAp(xs,mu z.throw z >> m)  >> m
};

def prd failure : Parser := cocase {
    Parse(xs,*) => throw MkUnit 
};

def prd seq : Parser -> Parser -> Parser := \p1 p2 => cocase {
    Parse(xs,m) => 
      p1 >> 
        Parse(xs,  MkPar(case { MkUnit => throw MkUnit >> m} ,
                           case { CoAp(l,f) => p2 >> Parse(l,MkPar(f,mu z. unit z >> m)) }) ) };

def prd alt : Parser -> Parser -> Parser := \p1 p2 => cocase {
    Parse(xs,m) => p1 >> Parse(xs,MkPar(case { MkUnit => p2 >> Parse(xs,m) },mu z. unit z >> m) )
};


def rec prd many1 : Parser -> Parser := \p => cocase {
    Parse(xs,m) => p >> Parse(xs, MkPar(case { MkUnit => throw MkUnit >> m} , 
                                            case { CoAp(l,f2) => alt success (many1 p) >> Parse(l,MkPar(f2, mu z. unit z >> m)) }))
};

def prd many : Parser -> Parser := \p => alt success (many1 p);

def prd parseOneTwo : Parser := seq (lit 1) (lit 2);
def prd parseOneTwoThree : Parser := seq (seq (lit 1) (lit 2)) (lit 3);

-- (123 | 12 | 35)^* 5 6
def prd parseComplicated : Parser := seq (seq (many (alt (alt parseOneTwoThree parseOneTwo) (seq (lit 3) (lit 5)))) (lit 5)) (lit 6);

def prd l4 : List(Nat) := Cons(1,Cons(2,Cons(3,Cons(5,Nil))));
def prd l5 : List(Nat) := Cons(1,Cons(2,Cons(3,Cons(5,Cons(5,Nil)))));
def prd l6 : List(Nat) := Cons(1,Cons(2,Cons(3,Cons(6,Cons(5,Nil)))));
def prd l7 : List(Nat) := Cons(1,Cons(2,Cons(5,Nil)));
def prd l8 : List(Nat) := Cons(1,Cons(2,Cons(3,Cons(5, Cons(5,Nil)))));
def prd l9 : List(Nat) := Cons(1,Cons(2,Cons(3,Cons(5, Cons(5,Cons(6,Nil))))));

def cmd test8  := parseComplicated >> Parse(l4,MkPar(print,print)) ;
def cmd test9  := parseComplicated >> Parse(l5,MkPar(print,print)) ;
def cmd test10 := parseComplicated >> Parse(l6,MkPar(print,print)) ;
def cmd test11 := parseComplicated >> Parse(l7,MkPar(print,print)) ;
def cmd test12 := parseComplicated >> Parse(l8,MkPar(print,print)) ;
def cmd test13 := parseComplicated >> Parse(l9,MkPar(print,print)) ;