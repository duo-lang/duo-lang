## Generic print consumer ##
cns print := mu x.Print(x);

## Boolean functions ##

## iftenelse :: forall t0. { 'Ap(< 'False | 'True >,t0,t0)[t0] }
## gives x out, if b is True, else y
prd ifthenelse := comatch { 
                    'Ap(b,x,y)[k] => b >> 
                      match { 'True => x >> k
                            , 'False => y >> k }};

## neg :: { 'Ap(< 'False | 'True >)[< 'False | 'True >] }
## boolean negation operation
prd neg        := comatch { 
                    'Ap(b)[k] => b >> 
                      match { 'True => 'False >> k
                            , 'False => 'True >> k }};

## and :: forall t0. { 'Ap((t0 /\ < 'False | 'True >),t0)[t0] }
## boolean and operation
prd and        := comatch {
                    'Ap(x,y)[k]   => ifthenelse >> 
                      'Ap(x,y,x)[k] };

## or :: forall t0. { 'Ap((t0 /\ < 'False | 'True >),t0)[t0] }
## boolean or operation
prd or         := comatch {
                    'Ap(x,y)[k]   => ifthenelse >> 
                      'Ap(x,x,y)[k] };

## nand ::  { 'Ap(< 'False | 'True >,< 'False | 'True >)[< 'False | 'True >] }
## boolean nand operation
prd nand       := comatch {
                    'Ap(x,y)[k]   => and >> 
                      'Ap(x,y)[mu z. neg >> 'Ap(z)[k]] };

## nor :: { 'Ap(< 'False | 'True >,< 'False | 'True >)[< 'False | 'True >] }
## boolean nor operation
prd nor        := comatch { 
                    'Ap(x,y)[k]   => or  >> 
                      'Ap(x,y)[mu z. neg >> 'Ap(z)[k]] };

## impl :: forall t0. { 'Ap(< 'False | 'True >,t0)[(t0 \/ < 'True >)] }
## boolean implication operation
prd impl       := comatch {
                    'Ap(x,y)[k]   => x >> 
                      match { 'True => y >> k
                            , 'False => 'True >> k } };

## basic functional stuff ##

## id :: forall t0. { 'Ap(t0)[t0] }
## gives the input out
prd id      := comatch { 'Ap(x)[k] => x >> k };


## curry :: forall t0t1t2. { 'Ap({ 'Ap(t2,t1)[t0] })[{ 'Ap(t2)[{ 'Ap(t1)[t0] }] }] }
## curries a given binary function f
prd curry   := comatch { 'Ap(f)[k]   => 
                 comatch { 'Ap(x)[k]   =>
                   comatch { 'Ap(y)[k]   => f >>
                     'Ap(x,y)[k] } >> 
                       k } >> 
                         k };

## uncurry :: forall t0t1t2. { 'Ap({ 'Ap(t2)[{ 'Ap(t1)[t0] }] })[{ 'Ap(t2,t1)[t0] }] }
## uncurries a binary function f
prd uncurry := comatch { 'Ap(f)[k] => 
                 comatch { 'Ap(x,y)[k] => f >> 
                   'Ap(x)['Ap(y)[k]] } >> k };

## comp :: forall t0t1t2. { 'Ap({ 'Ap(t0)[t1] },{ 'Ap(t2)[t0] })[{ 'Ap(t2)[t1] }] }
## constructs the compostion f(g(x))
prd comp    := comatch { 'Ap(f,g)[k] => 
                 comatch { 'Ap(x)[k] => g >> 
                   'Ap(x)[mu w. f >> 'Ap(w)[k]] } >> k };

## twice :: forall t0t1. { 'Ap({ 'Ap(t0)[(t0 /\ t1)] })[{ 'Ap(t0)[t1] }] }
## evaluates f(f(x))
prd twice   := comatch { 'Ap(f)[k] => 
                 comatch { 'Ap(x)[k] => comp >> 
                   'Ap(f,f)['Ap(x)[k]] } >> k };

## twice :: forall t0t1. { 'Ap({ 'Ap((t0 \/ t1))[t0] })[{ 'Ap(t1)[t0] }] }
## evaluates f(f(f(x)))
prd thrice  := comatch { 'Ap(f)[k] => 
                 comatch { 'Ap(x)[k] => comp >> 
                   'Ap(f,f)[mu g. comp >> 
                     'Ap(g,f)['Ap(x)[k]]] } >> k };

## fixed point combinators ##

## fix :: forall t0t1t2. { 'Ap({ 'Ap({ 'Ap(t1)[t0] })[(t2 /\ { 'Ap(t1)[t0] })] })[t2] }
## evaluates fixpoint of f
prd fix := comatch { 'Ap(f)[k] => 
             comatch { 'Ap(x)[k] => f >> 
               'Ap( comatch { 'Ap(v)[k] => x >> 'Ap(x)['Ap(v)[k]] })[k] } >> 
                 'Ap( comatch { 'Ap(x)[k] => f >> 
                   'Ap( comatch { 'Ap(v)[k] => x >> 'Ap(x)['Ap(v)[k]] })[k] })[k] };

## fixLazy :: forall t0. { 'Ap({ 'Ap(t0)[t0] })[t0] }
## layz variant of fix
prd fixLazy := comatch { 'Ap(f)[k] => 
                 comatch { 'Ap(x)[k] => x >> 
                   'Ap(x)[mu xx. f >> 'Ap(xx)[k]] } >> 
                      'Ap(comatch { 'Ap(x)[k] => x >> 
                        'Ap(x)[mu xx. f >> 'Ap(xx)[k]] })[k]};

## basic recursive functions ##

## recZ :: { 'Ap(rec r0.< 'S(r0) | 'Z >)[< 'Z >] }
## iterates n times and gives zero out
prd recZ := comatch { 'Ap(n)[k] => fix >>
                           'Ap(comatch { 'Ap(alpha)[k] => 
                              comatch { 'Ap(n)[k] => n >> 
                                match { 'Z => 'Z >> k
                                      , 'S(p) => alpha >> 
                                          'Ap(p)[k] }} >> k})['Ap(n)[k]] };

## retItself :: rec r1.{ 'Ap(Top)[r1] }
## iterates over arbitrary recursive data and gives the base-case out
prd retItself := comatch { 'Ap(x)[k] =>
                   comatch { 'Ap(x)[k] => 
                     comatch { 'Ap(y)[k] => x >> 
                       'Ap(x)[k] } >> k } >> 
                         'Ap(comatch { 'Ap(x)[k] => 
                               comatch { 'Ap(y)[k] => x >> 'Ap(x)[k] } >>
                                           k })[k] };

## omega :: Bot
## omega combinator
prd omega     := mu k. comatch { 'Ap(x)[k] => x >> 'Ap(x)[k] } >> 
                         'Ap( comatch { 'Ap(x)[k] => x >> 'Ap(x)[k] })[k];

## natural number arithmetic

## succ :: forall t0. { 'Ap(t0)[< 'S(t0) >] }
## computes successor of n
prd succ := comatch { 'Ap(n)[k] => 'S(n) >> k };

## pred :: forall t0. { 'Ap(< 'S(t0) >)[t0] }
## computes predecessor of an n > 0
prd pred := comatch { 'Ap(n)[k] => n >>
                        match { 'S(m) => m >> k } };

## add :: forall t0. { 'Ap(t0,rec r1.< 'S(r1) | 'Z >)[rec r3.(t0 \/ < 'S(r3) >)] }
## adds two nats n and m
prd add := comatch { 
             'Ap(n,m)[k] => fix >> 
               'Ap( comatch { 'Ap(alpha)[k] => 
                      comatch { 'Ap(m)[k] => m >> 
                        match { 'Z => n >> k
                              , 'S(p) => alpha >> 
                                  'Ap(p)[mu w. 'S(w) >> k] }} >> k })['Ap(m)[k]] };

## mlt :: forall t0. { 'Ap((t0 /\ < 'S(rec r1.< 'S(r1) | 'Z >) | 'Z >)
##                         , rec r1.< 'S(r1) | 'Z >)[(t0 \/ < 'S(rec r5.(t0 \/ < 'S(r5) >)) | 'Z >)] }
## multiplies two nats n and m
prd mlt := comatch { 
             'Ap(n,m)[k] => fix >> 
               'Ap(comatch { 'Ap(alpha)[k] =>
                     comatch { 'Ap(m)[k] => m >> 
                       match { 'Z => 'Z >> k
                             , 'S(p) => alpha >> 
                                 'Ap(p)[mu w. add >> 
                                   'Ap(n,w)[k]] } } >> k })['Ap(m)[k]]};

## exp :: forall t0. { 'Ap((t0 /\ < 'S(rec r1.< 'S(r1) | 'Z >) | 'Z >) , rec r1.< 'S(r1) | 'Z >)
##                        [(t0 \/ < 'S((t0 \/ < 'S(rec r6.(t0 \/ < 'S(r6) >)) | 'Z >)) | 'Z >)] }
## evaluates n raised to the power of m
prd exp := comatch {
             'Ap(n,m)[k] => fix >>
               'Ap(comatch { 'Ap(alpha)[k] => 
                     comatch { 'Ap(m)[k] => m >> 
                       match { 'Z => 'S('Z) >> k
                             , 'S(p) => alpha >> 
                                 'Ap(p)[mu w. mlt >> 'Ap(n,w)[k]] } } >> k })['Ap(m)[k]] };

## sub :: forall t0. { 'Ap(rec r0.(t0 /\ < 'S(r0) >),rec r1.< 'S(r1) | 'Z >)[t0] }
## subtraction m from n
prd sub := comatch {
             'Ap(n,m)[k] => fix >>
               'Ap(comatch { 'Ap(alpha)[k] => 
                     comatch { 'Ap(m)[k] => m >> 
                       match { 'Z => n >> k
                             , 'S(p) => alpha >> 
                                 'Ap(p)[mu w. pred >> 'Ap(w)[k]] }} >> k })['Ap(m)[k]] };

## subSafe :: forall t0. { 'Ap(rec r0.(t0 /\ < 'S(r0) | 'Z >),rec r1.< 'S(r1) | 'Z >)[t0] }
## total subtraction m from n 
prd subSafe := comatch {
                 'Ap(n,m)[k] => fix >>
                   'Ap(comatch { 'Ap(alpha)[k] =>
                         comatch { 'Ap(n)[k] => 
                           comatch { 'Ap(m)[k] => m >> 
                             match { 'Z => n >> k
                                   , 'S(mp) => n >> 
                                       match { 'Z => n >> k
                                             , 'S(np) => alpha >> 
                                                 'Ap(np)['Ap(mp)[k]] }}} >> k } >> k })['Ap(n)['Ap(m)[k]]]};

## foldNat :: forall t0. { 'Ap(rec r0.< 'S(r0) | 'Z >,t0,{ 'Ap(t0)[t0] })[t0] }
## folding over nats
prd foldNat := comatch {
                'Ap(n,x,f)[k] => fix >>
                  'Ap( comatch { 'Ap(alpha)[k] => 
                         comatch { 'Ap(n)[k] => 
                           comatch { 'Ap(x)[k] => n >> 
                             match { 'Z => x >> k
                                   , 'S(p) => f >> 
                                       'Ap(x)[mu w. alpha >> 
                                         'Ap(p)['Ap(w)[k]]] } } >> k } >> k })
                     ['Ap(n)['Ap(x)[k]]] };

## foldNat1 :: forall t0t1. { 'Ap(rec r0.< 'S(r0) >,t1,{ 'Ap((t0 \/ t1))[t0] })[t0] }
## folding over nats
prd foldNat1 := comatch {
                  'Ap(n,x,f)[k] => fix >> 
                    'Ap( comatch { 'Ap(alpha)[k] => 
                           comatch { 'Ap(n)[k] => 
                             comatch { 'Ap(x)[k] => n >> 
                               match { 'S(m) => m >> 
                                 match { 'Z => f >> 
                                   'Ap(x)[k], 'S(p) => f >> 
                                     'Ap(x)[mu w. alpha >> 
                                       'Ap(m)['Ap(w)[k]]] }}} >> k } >> k })
                       ['Ap(n)['Ap(x)[k]]]};


## ltUnsafe :: { 'Ap(rec r0.< 'S(r0) | 'Z >,rec r1.< 'S(r1) >)[< 'True >] }
## "m < n" operator, where n > 0
prd ltUnsafe := comatch { 
                  'Ap(n,m)[k] => fix >> 
                    'Ap( comatch { 'Ap(alpha)[k] => 
                           comatch { 'Ap(n)[k] => 
                             comatch { 'Ap(m)[k] => n >> 
                               match { 'Z => 'True >> k
                                     , 'S(np) => m >> 
                                         match { 'S(mp) => alpha >> 
                                                   'Ap(np)['Ap(mp)[k]] }}} >> k } >> k })
                       ['Ap(n)['Ap(m)[k]]] };

## ltSafe  :: { 'Ap(rec r0.< 'S(r0) | 'Z >,rec r0.< 'S(r0) | 'Z >)[< 'False | 'True >] }
## "m < n" operator
prd ltSafe := comatch { 
                'Ap(n,m)[k] => fix >> 
                  'Ap(comatch { 
                    'Ap(alpha)[k] => 
                      comatch { 'Ap(n)[k] => 
                        comatch { 'Ap(m)[k] => n >> 
                                    match { 'Z => 'True >> k
                                          , 'S(np) => m >> 
                                            match { 'Z => 'False >> k
                                                  , 'S(mp) => alpha >> 
                                                      'Ap(np)['Ap(mp)[k]] }}} >> k } >> k })
                     ['Ap(n)['Ap(m)[k]]] };

## eqUnsafe :: { 'Ap(rec r0.< 'S(r0) | 'Z >,<  >)[< 'True >] }
## checks if n equals m
prd eqUnsafe := comatch { 
                  'Ap(n,m)[k] => fix >> 
                    'Ap( comatch { 'Ap(alpha)[k] => 
                      comatch { 'Ap(n)[k] => 
                        comatch { 'Ap(m)[k] => n >> 
                          match { 'Z => m >> match { 'Z => 'True >> k }
                                , 'S(np) => m >> match { 'S(mp) => alpha >> 
                                                           'Ap(np)['Ap(mp)[k]] }}} >> k } >> k })
                       ['Ap(n)['Ap(m)[k]]] };

## eqSafe :: { 'Ap(rec r0.< 'S(r0) | 'Z >,rec r0.< 'S(r0) | 'Z >)[< 'False | 'True >] }
## checks if n equals m
prd eqSafe := comatch { 
                'Ap(n,m)[k] => fix >> 
                  'Ap(comatch { 
                    'Ap(alpha)[k] => 
                      comatch { 'Ap(n)[k] => 
                        comatch { 'Ap(m)[k] => n >> 
                          match { 'Z => m >> 
                            match { 'Z => 'True >> k
                                  , 'S(mp) => 'False >> k }
                                , 'S(np) => m >> 
                                    match { 'Z => 'False >> k
                                          , 'S(mp) => alpha >> 
                                              'Ap(np)['Ap(mp)[k]] } } } >> k } >> k })
                     ['Ap(n)['Ap(m)[k]]] };

## times2 :: { 'Ap(rec r0.< 'S(r0) | 'Z >)[rec r1.< 'S(< 'S(r1) >) | 'Z >] }
## multiplies n by two
prd times2 := comatch {
                'Ap(n)[k] => fix >> 
                  'Ap( comatch { 
                         'Ap(alpha)[k] => 
                           comatch { 'Ap(n)[k] => n >> 
                             match { 'Z => 'Z >> k
                                   , 'S(m) => alpha >> 'Ap(m)[mu w. 'S('S(w)) >> k]}} >> k })
                     ['Ap(n)[k]]};

## times3 :: { 'Ap(rec r0.< 'S(r0) | 'Z >)
##                [rec r1.< 'S(< 'S(< 'S(r1) >) >) | 'Z >] }
## multiplies n by three
prd times3 := comatch { 
                'Ap(n)[k] => fix >> 
                  'Ap( comatch { 
                         'Ap(alpha)[k] => 
                           comatch { 'Ap(n)[k] => n >> 
                            match { 'Z => 'Z >> k
                                  , 'S(m) => alpha >> 
                                      'Ap(m)[mu w. 'S('S('S(w))) >> k] } } >> k })
                     ['Ap(n)[k]] };

## times2or3 :: { 'Ap(< 'False | 'True >
##                   , rec r1.< 'S(r1) | 'Z >)
##                   [rec r3.< 'S(< 'S(< 'S(< 'S(< 'S(< 'S(r3) >) | 'Z >) | 'Z >) | 'Z >) >) | 'Z >] }
## multiplies n by two or three
prd times2or3 := comatch {
                   'Ap(b,n)[k] => b >> 
                     match { 'True => times2 >> 'Ap(n)[k]
                           , 'False => times3 >> 'Ap(n)[k] } };

## times2and3 :: { 'Ap(rec r0.< 'S(r0) | 'Z >)[rec r1.< 'S(< 'S(r1) >) | 'Z >] }
## multiplies n consecutively by two and three
prd times2and3 := comatch { 
                    'Ap(n)[k] => comp >> 
                      'Ap(times2, times3)['Ap(n)[k]]};

## div2 :: { 'Ap(rec r0.< 'S(< 'S(r0) >) | 'Z >)[rec r1.< 'S(r1) | 'Z >] }
## divides n by two
prd div2 := comatch { 
              'Ap(n)[k] => fix >> 
                'Ap( comatch { 'Ap(alpha)[k] => 
                       comatch { 'Ap(n)[k] => n >> 
                                   match { 'Z => 'Z >> k
                                         , 'S(m) => m >> 
                                             match { 'S(p) => alpha >> 
                                              'Ap(p)[mu w. 'S(w) >> k]}}} >> k })
                   ['Ap(n)[k]] };

## div3 :: { 'Ap(rec r0.< 'S(< 'S(< 'S(r0) >) >) | 'Z >)[rec r1.< 'S(r1) | 'Z >] }
## divides n by three
prd div3 := comatch { 
              'Ap(n)[k] => fix >> 
                'Ap( comatch { 'Ap(alpha)[k] => 
                       comatch { 'Ap(n)[k] => n >>
                         match { 'Z => 'Z >> k
                               , 'S(m) => m >> 
                                   match { 'S(p) => p >> 
                                     match { 'S(r) => alpha >>
                                       'Ap(r)[mu w. 'S(w) >> k] }}}} >> k })
                  ['Ap(n)[k]]};

## div2or3 :: { 'Ap(< 'False | 'True >
##                 , rec r1.< 'S(< 'S(< 'S(< 'S(< 'S(< 'S(r1) >) >) >) >) >) | 'Z >)
##                 [rec r8.< 'S(r8) | 'Z >] }
## divides n by two or by three
prd div2or3 := comatch { 
                 'Ap(b,n)[k] => b >> 
                   match { 'True  => div2 >> 'Ap(n)[k]
                         , 'False => div3 >> 'Ap(n)[k] }};

## pairs (data type)

## fst :: forall t0. { 'Ap(< 'Pair(t0,Top) >)[t0] }
## extract the first component of a pair
prd fst := comatch { 'Ap(p)[k] => p >> match { 'Pair(x,y) => x >> k }};

## snd :: forall t0. { 'Ap(< 'Pair(Top,t0) >)[t0] }
## extract the second component of a pair
prd snd := comatch { 'Ap(p)[k] => p >> match { 'Pair(x,y) => y >> k }};

## bimapDat :: forall t0t1t2t3. { 'Ap( { 'Ap(t3)[t1] } , { 'Ap(t2)[t0] } , < 'Pair(t3,t2) >)
##                                   [< 'Pair(t1,t0) >] }
## given two functions f and g, maps f to the first and g to the second component
prd bimapDat := comatch { 'Ap(f,g,p)[k] => p >> 
                            match { 'Pair(x,y) => f >> 
                                      'Ap(x)[mu fx. g >> 
                                              'Ap(y)[mu gy. 'Pair(fx,gy) >> k]] }};

## pairs (codata type)

## pair :: forall t0t1. { 'Ap(t1,t0)[{ 'Fst[t1] , 'Snd[t0] }] }
## constructs a pair (x,y)
prd pair := comatch { 'Ap(x,y)[k] => 
                        comatch { 'Fst[k1] => x >> k1
                                , 'Snd[k2] => y >> k2 } >> k };

## bimapCodat :: forall t0t1t2t3. { 'Ap({ 'Ap(t2)[t3] },{ 'Ap(t0)[t1] },{ 'Fst[t2] , 'Snd[t0] })
##                                     [{ 'Fst[t3] , 'Snd[t1] }] }
## given two functions f and g, maps f to the first and g to the second component
prd bimapCodat := comatch { 'Ap(f,g,p)[k] => 
                    comatch { 
                      'Fst[k1] => p >> 
                        'Fst[mu x. f >> 'Ap(x)[k1]]
                    , 'Snd[k2] => p >> 
                        'Snd[mu y. g >> 'Ap(y)[k2]] }
                     >> k };

## lists (data type)

## map :: forall t0t1. { 'Ap( { 'Ap(t1)[t0] }
##                          , rec r1.< 'Cons(t1,r1) | 'Nil >)
##                          [rec r5.< 'Cons(t0,r5) | 'Nil >] }
## applies f to each element of xs
prd map := comatch { 
             'Ap(f, xs)[k] => fix >> 
               'Ap( comatch { 'Ap(alpha)[k] => 
                      comatch { 'Ap(xs)[k] => xs >> 
                        match { 'Nil => 'Nil >> k
                              , 'Cons(p,ys) => alpha >> 
                                  'Ap(ys)[mu w1. f >> 
                                    'Ap(p)[mu w2. 'Cons(w2,w1) >> k]] } } >> k})
                  ['Ap(xs)[k]]};

## head :: forall t0. { 'Ap(< 'Cons(t0,Top) >)[t0] }
## returns the head of the non-empty list xs
prd head := comatch { 'Ap(xs)[k] => xs >> 
              match { 'Cons(x,xs) => x >> k }};

## tail :: forall t0. { 'Ap(< 'Cons(Top,t0) >)[t0] }
## returns the tail of the non-empty list xs
prd tail := comatch { 'Ap(xs)[k] => xs >> #
              match { 'Cons(x,xs) => xs >> k }};

## null :: { 'Ap(< 'Cons(Top,Top) | 'Nil >)[< 'False | 'True >] }
## returns True if a list is empty, otherwise False 
prd null := comatch { 'Ap(xs)[k] => xs >> 
              match { 'Nil => 'True >> k
                    , 'Cons(x,rest) => 'False >> k }};

## append :: forall t0t1. { 'Ap(rec r0.< 'Cons(t1,r0) | 'Nil >,t0)
##                             [rec r5.(t0 \/ < 'Cons(t1,r5) >)] }
## concatenates two lists
prd append := comatch { 'Ap(xs,ys)[k] => fix >> 
                'Ap( comatch { 'Ap(alpha)[k] => 
                       comatch { 'Ap(xs)[k] => xs >> 
                         match { 'Nil          => ys >> k
                               , 'Cons(x,rest) => alpha >> 
                                   'Ap(rest)[mu w. 'Cons(x,w) >> k] }} >> k })
                   ['Ap(xs)[k]]};

## elemAt :: forall t0. { 'Ap(rec r0.< 'Cons(t0,r0) >,rec r1.< 'S(r1) | 'Z >)[t0] }
## gives the eleement at the index
prd elemAt := comatch { 'Ap(xs,n)[k] => fix >> 
               'Ap( comatch { 'Ap(alpha)[k] => 
                      comatch { 'Ap(xs)[k] => 
                        comatch { 'Ap(n)[k] => n >> 
                          match { 'Z    => head >> 'Ap(xs)[k]
                                , 'S(p) => tail >> 
                                    'Ap(xs)[mu w. alpha >> 
                                                    'Ap(w)['Ap(p)[k]]] }} >> k } >> k })
                  ['Ap(xs)['Ap(n)[k]]] };

## foldl :: forall t0t1. { 'Ap({ 'Ap(t1,t0)[t1] },t1,rec r4.< 'Cons(t0,r4) | 'Nil >)[t1] }
## folds f over xs and gives x out in the empty case
prd foldl := comatch { 'Ap(f,x,xs)[k] => fix >> 
              'Ap( comatch { 'Ap(alpha)[k] => 
                     comatch { 'Ap(x)[k] => 
                       comatch { 'Ap(xs)[k] => xs >> 
                         match { 'Nil => x >> k
                               , 'Cons(y,ys) => f >> 
                                   'Ap(x,y)[mu fxy.alpha >> 
                                                    'Ap(fxy)['Ap(ys)[k]]] } } >> k } >> k })
                 ['Ap(x)['Ap(xs)[k]]] };

## reverse :: forall t0. { 'Ap(rec r0.< 'Cons(t0,r0) | 'Nil >)[rec r1.< 'Cons(t0,r1) | 'Nil >] }
## returns the elements of xs in reverse order
prd reverse := comatch { 'Ap(xs)[k] => fix >> #
                 'Ap( comatch { 'Ap(alpha)[k] => 
                        comatch { 'Ap(xs)[k] => xs >> 
                          match { 'Nil => 'Nil >> k
                                , 'Cons(x,rest) => alpha >> 
                                    'Ap(rest)[mu w. append >> 
                                                      'Ap(w,'Cons(x,'Nil))[k]] }} >> k })
                    ['Ap(xs)[k]] };

## length :: { 'Ap(rec r0.< 'Cons(Top,r0) | 'Nil >)[rec r1.< 'S(r1) | 'Z >] }
##  returns the number of items in a list 
prd length := comatch { 'Ap(xs)[k] => fix >> 
                'Ap( comatch { 'Ap(alpha)[k] => 
                       comatch { 'Ap(xs)[k] => xs >> 
                         match { 'Nil => 'Z >> k
                               , 'Cons(x,rest) => alpha >>
                                   'Ap(rest)[mu w. 'S(w) >> k]}} >> k })
                   ['Ap(xs)[k]]};

## filter :: forall t0. { 'Ap( { 'Ap(t0)[< 'False | 'True >] }
##                           , rec r1.< 'Cons(t0,r1) | 'Nil >)
##                           [rec r5.< 'Cons(t0, r5) | 'Nil >] }
## filters out all elements of xs, not holding p
prd filter := comatch { 'Ap(p,xs)[k] => fix >> 
                'Ap( comatch { 'Ap(alpha)[k] => 
                       comatch { 'Ap(xs)[k] => xs >>
                         match { 'Nil => 'Nil >> k
                               , 'Cons(x,rest) => p >> 
                                   'Ap(x)[ match { 'True  => alpha >> 'Ap(rest)[mu w. 'Cons(x,w) >> k]
                                                 , 'False => alpha >> 'Ap(rest)[k] }] } } >> k })
                   ['Ap(xs)[k]]};


## lists (codata type)

## consNeg :: forall t0t1. { 'Ap(t1,t0)[{ 'Head[t1] , 'Tail[t0] }] }
## inserts x as head in list xs
prd consNeg := comatch { 'Ap(x,xs)[k] => 
                 comatch { 'Head[k] => x >> k
                         , 'Tail[k] => xs >> k } >> k };

## mapNeg :: forall t0t1. { 'Ap( { 'Ap(t0)[t1] }
##                             , rec r1.{ 'Head[t0] , 'Tail[r1] })
##                             [rec r7.{ 'Head[t1] , 'Tail[r7] }] }
## applies f to each element of xs
prd mapNeg := comatch { 'Ap(f,xs)[k] => fix >>
               'Ap( comatch { 'Ap(alpha)[k] => 
                      comatch { 'Ap(xs)[k] => 
                        comatch { 'Head[k] => xs >> 'Head[mu w. f >> 'Ap(w)[k]]#
                                , 'Tail[k] => xs >> 'Tail[mu w. alpha >> 
                                                      'Ap(w)[k]]} >> k } >> k })
                  ['Ap(xs)[k]] };

## elemAtNeg :: forall t0. { 'Ap( rec r0.{ 'Head[t0] , 'Tail[r0] }
##                              , rec r1.< 'S(r1) | 'Z >)
##                              [t0] }
## gives the eleement at the index
prd elemAtNeg := comatch { 'Ap(xs,n)[k] => fix >> 
                   'Ap( comatch { 'Ap(alpha)[k] => 
                          comatch { 'Ap(xs)[k] => 
                            comatch { 'Ap(n)[k] => n >> 
                              match { 'Z => xs >> 'Head[k]
                                    , 'S(m) => xs >> 'Tail[mu ys. alpha >> 
                                                       'Ap(ys)['Ap(m)[k]]] }} >> k } >> k })
                      ['Ap(xs)['Ap(n)[k]]]};

## repeat :: forall t0. { 'Ap(t0)[rec r1.{ 'Head[t0] , 'Tail[r1] }] }
## creates an infinite list where all items are the first argument 
prd repeat := comatch { 'Ap(x)[k] => fixLazy >> 
                'Ap( comatch { 'Ap(alpha)[k] => 
                       comatch { 'Head[k] => x >> k
                               , 'Tail[k] => alpha >> k } >> k })
                   [k]};


## misc interesting terms

# prd doubleCycle := comatch { 'Ap(x) => fix >> 'Ap(comatch { 'Ap(alpha)[k] => comatch { 'Ap(x) => x >> match { 'X(x1) => x1 >> match { 'X(x2) => alpha >> 'Ap(x2)}, 'Y(y1) => y1 >> match { 'Y(y2) => alpha >> 'Ap(y2)}}} >> k })['Ap(x)]};
prd faultyEdgeTest := comatch { 'Ap(b,f) => b >> match { 'True => f >> match { 'X(x) => Done, 'Y(x) => Done }, 'False => f >> match { 'X(x) => Done, 'Z(x)=>Done }}};
prd oneortwo := comatch { 'Ap(b)[k] => b >> match { 'True => 'S('Z) >> k, 'False => 'S('S('Z)) >> k }};
prd admissabilityTest := comatch { 'Ap(f)[k] => 'True >> match { 'True => comatch { 'Ap(x)[k] => f >> 'Ap(x)[k]} >> k, 'False => f >> k }};

prd implicationConstraintsTest1 := comatch { 'Ap(x) => x >> match { 'A => Done, 'B => x >> match { 'B => Done }}};

prd parserTest := comatch { 'Ap(x)[x] => x >> x };

## Nominal Types

data Bool : Type CBV { TT, FF };
data Nat : Type CBV { Z, S(Nat) };
codata NatBoolFun : Type CBN { Ap(Nat)[Bool] };
prd nominalNot := comatch { 'Ap(x)[k] => x >> match { TT => FF >> k, FF => TT >> k }};

prd addNominal := comatch { 'Ap(n,m)[k] => fix >> 'Ap( comatch { 'Ap(alpha)[k] => comatch { 'Ap(m)[k] => m >> match { Z => n >> k, S(p) => alpha >> 'Ap(p)[mu w. S(w) >> k] }} >> k })['Ap(m)[k]] };
prd mltNominal := comatch { 'Ap(n,m)[k] => fix >> 'Ap(comatch { 'Ap(alpha)[k] => comatch { 'Ap(m)[k] => m >> match { Z => Z >> k, S(p) => alpha >> 'Ap(p)[mu w. addNominal >> 'Ap(n,w)[k]] } } >> k })['Ap(m)[k]]};
prd expNominal := comatch { 'Ap(n,m)[k] => fix >> 'Ap(comatch { 'Ap(alpha)[k] => comatch { 'Ap(m)[k] => m >> match { Z => S(Z) >> k, S(p) => alpha >> 'Ap(p)[mu w. mltNominal >> 'Ap(n,w)[k]] } } >> k })['Ap(m)[k]] };
prd subSafeNominal := comatch { 'Ap(n,m)[k] => fix >> 'Ap(comatch { 'Ap(alpha)[k] => comatch { 'Ap(n)[k] => comatch { 'Ap(m)[k] => m >> match { Z => n >> k, S(mp) => n >> match { Z => n >> k, S(np) => alpha >> 'Ap(np)['Ap(mp)[k]] }}} >> k } >> k })['Ap(n)['Ap(m)[k]]]};

cmd exampleCommand1 := Print(2);
cmd exampleCommand2 := mu x.Print(2) >> mu y. Print(4);

prd newStylePredTwo := (cocase { 'Ap(x)[*] => case x of { 'Z() => 'Z(), 'S(x) => x }}.'Ap('S('S('S('Z())))));
