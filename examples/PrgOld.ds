## Generic print consumer ##
cns print := mu x.Print(x); Done;

## Boolean functions ##

constructor True : CBV;
constructor False : CBV;
destructor Ap : CBN;
constructor Zero : CBV;
constructor S : CBV;
constructor Pair : CBV;
destructor Fst : CBN;
destructor Snd : CBN;
constructor Nil : CBV;
constructor Cons : CBV;
destructor Head : CBN;
destructor Tail : CBN;
constructor X : CBV;
constructor A : CBV;
constructor B : CBV;


## iftenelse :: forall t0. { Ap(< False | True >,t0,t0)[t0] }
## gives x out, if b is True, else y
prd ifthenelse := cocase {
                    Ap(b,x,y)[k] => b >>
                      case { True => x >> k
                            , False => y >> k }};

## neg :: { Ap(< False | True >)[< False | True >] }
## boolean negation operation
prd neg        := cocase {
                    Ap(b)[k] => b >>
                      case { True => False >> k
                            , False => True >> k }};

## and :: forall t0. { Ap((t0 /\ < False | True >),t0)[t0] }
## boolean and operation
prd and        := cocase {
                    Ap(x,y)[k]   => ifthenelse >>
                      Ap(x,y,x)[k] };

## or :: forall t0. { Ap((t0 /\ < False | True >),t0)[t0] }
## boolean or operation
prd or         := cocase {
                    Ap(x,y)[k]   => ifthenelse >>
                      Ap(x,x,y)[k] };

## nand ::  { Ap(< False | True >,< False | True >)[< False | True >] }
## boolean nand operation
prd nand       := cocase {
                    Ap(x,y)[k]   => and >>
                      Ap(x,y)[mu z. neg >> Ap(z)[k]] };

## nor :: { Ap(< False | True >,< False | True >)[< False | True >] }
## boolean nor operation
prd nor        := cocase {
                    Ap(x,y)[k]   => or  >>
                      Ap(x,y)[mu z. neg >> Ap(z)[k]] };

## impl :: forall t0. { Ap(< False | True >,t0)[(t0 \/ < True >)] }
## boolean implication operation
prd impl       := cocase {
                    Ap(x,y)[k]   => x >>
                      case { True => y >> k
                            , False => True >> k } };

## basic functional stuff ##

## id :: forall t0. { Ap(t0)[t0] }
## gives the input out
prd id      := cocase { Ap(x)[k] => x >> k };


## curry :: forall t0t1t2. { Ap({ Ap(t2,t1)[t0] })[{ Ap(t2)[{ Ap(t1)[t0] }] }] }
## curries a given binary function f
prd curry   := cocase { Ap(f)[k]   =>
                 cocase { Ap(x)[k]   =>
                   cocase { Ap(y)[k]   => f >>
                     Ap(x,y)[k] } >>
                       k } >>
                         k };

## uncurry :: forall t0t1t2. { Ap({ Ap(t2)[{ Ap(t1)[t0] }] })[{ Ap(t2,t1)[t0] }] }
## uncurries a binary function f
prd uncurry := cocase { Ap(f)[k] =>
                 cocase { Ap(x,y)[k] => f >>
                   Ap(x)[Ap(y)[k]] } >> k };

## comp :: forall t0t1t2. { Ap({ Ap(t0)[t1] },{ Ap(t2)[t0] })[{ Ap(t2)[t1] }] }
## constructs the compostion f(g(x))
prd comp    := cocase { Ap(f,g)[k] =>
                 cocase { Ap(x)[k] => g >>
                   Ap(x)[mu w. f >> Ap(w)[k]] } >> k };

## twice :: forall t0t1. { Ap({ Ap(t0)[(t0 /\ t1)] })[{ Ap(t0)[t1] }] }
## evaluates f(f(x))
prd twice   := cocase { Ap(f)[k] =>
                 cocase { Ap(x)[k] => comp >>
                   Ap(f,f)[Ap(x)[k]] } >> k };

## twice :: forall t0t1. { Ap({ Ap((t0 \/ t1))[t0] })[{ Ap(t1)[t0] }] }
## evaluates f(f(f(x)))
prd thrice  := cocase { Ap(f)[k] =>
                 cocase { Ap(x)[k] => comp >>
                   Ap(f,f)[mu g. comp >>
                     Ap(g,f)[Ap(x)[k]]] } >> k };

## fixed point combinators ##

## fix :: forall t0t1t2. { Ap({ Ap({ Ap(t1)[t0] })[(t2 /\ { Ap(t1)[t0] })] })[t2] }
## evaluates fixpoint of f
prd fix := cocase { Ap(f)[k] =>
             cocase { Ap(x)[k] => f >>
               Ap( cocase { Ap(v)[k] => x >> Ap(x)[Ap(v)[k]] })[k] } >>
                 Ap( cocase { Ap(x)[k] => f >>
                   Ap( cocase { Ap(v)[k] => x >> Ap(x)[Ap(v)[k]] })[k] })[k] };

## fixLazy :: forall t0. { Ap({ Ap(t0)[t0] })[t0] }
## layz variant of fix
prd fixLazy := cocase { Ap(f)[k] =>
                 cocase { Ap(x)[k] => x >>
                   Ap(x)[mu xx. f >> Ap(xx)[k]] } >>
                      Ap(cocase { Ap(x)[k] => x >>
                        Ap(x)[mu xx. f >> Ap(xx)[k]] })[k]};

## basic recursive functions ##

## recZero :: { Ap(rec r0.< S(r0) | Zero >)[< Zero >] }
## iterates n times and gives zero out
prd recZero := cocase { Ap(n)[k] => fix >>
                           Ap(cocase { Ap(alpha)[k] =>
                              cocase { Ap(n)[k] => n >>
                                case { Zero => Zero >> k
                                      , S(p) => alpha >>
                                          Ap(p)[k] }} >> k})[Ap(n)[k]] };

## retItself :: rec r1.{ Ap(Top)[r1] }
## iterates over arbitrary recursive data and gives the base-case out
prd retItself := cocase { Ap(x)[k] =>
                   cocase { Ap(x)[k] =>
                     cocase { Ap(y)[k] => x >>
                       Ap(x)[k] } >> k } >>
                         Ap(cocase { Ap(x)[k] =>
                               cocase { Ap(y)[k] => x >> Ap(x)[k] } >>
                                           k })[k] };

## omega :: Bot
## omega combinator
prd omega     := mu k. cocase { Ap(x)[k] => x >> Ap(x)[k] } >>
                         Ap( cocase { Ap(x)[k] => x >> Ap(x)[k] })[k];

## natural number arithmetic

## succ :: forall t0. { Ap(t0)[< S(t0) >] }
## computes successor of n
prd succ := cocase { Ap(n)[k] => S(n) >> k };

## pred :: forall t0. { Ap(< S(t0) >)[t0] }
## computes predecessor of an n > 0
prd pred := cocase { Ap(n)[k] => n >>
                        case { S(m) => m >> k } };

## add :: forall t0. { Ap(t0,rec r1.< S(r1) | Zero >)[rec r3.(t0 \/ < S(r3) >)] }
## adds two nats n and m
prd add := cocase {
             Ap(n,m)[k] => fix >>
               Ap( cocase { Ap(alpha)[k] =>
                      cocase { Ap(m)[k] => m >>
                        case { Zero => n >> k
                              , S(p) => alpha >>
                                  Ap(p)[mu w. S(w) >> k] }} >> k })[Ap(m)[k]] };

## mlt :: forall t0. { Ap((t0 /\ < S(rec r1.< S(r1) | Zero >) | Zero >)
##                         , rec r1.< S(r1) | Zero >)[(t0 \/ < S(rec r5.(t0 \/ < S(r5) >)) | Zero >)] }
## multiplies two nats n and m
prd mlt := cocase {
             Ap(n,m)[k] => fix >>
               Ap(cocase { Ap(alpha)[k] =>
                     cocase { Ap(m)[k] => m >>
                       case { Zero => Zero >> k
                             , S(p) => alpha >>
                                 Ap(p)[mu w. add >>
                                   Ap(n,w)[k]] } } >> k })[Ap(m)[k]]};

## exp :: forall t0. { Ap((t0 /\ < S(rec r1.< S(r1) | Zero >) | Zero >) , rec r1.< S(r1) | Zero >)
##                        [(t0 \/ < S((t0 \/ < S(rec r6.(t0 \/ < S(r6) >)) | Zero >)) | Zero >)] }
## evaluates n raised to the power of m
prd exp := cocase {
             Ap(n,m)[k] => fix >>
               Ap(cocase { Ap(alpha)[k] =>
                     cocase { Ap(m)[k] => m >>
                       case { Zero => S(Zero) >> k
                             , S(p) => alpha >>
                                 Ap(p)[mu w. mlt >> Ap(n,w)[k]] } } >> k })[Ap(m)[k]] };

## sub :: forall t0. { Ap(rec r0.(t0 /\ < S(r0) >),rec r1.< S(r1) | Zero >)[t0] }
## subtraction m from n
prd sub := cocase {
             Ap(n,m)[k] => fix >>
               Ap(cocase { Ap(alpha)[k] =>
                     cocase { Ap(m)[k] => m >>
                       case { Zero => n >> k
                             , S(p) => alpha >>
                                 Ap(p)[mu w. pred >> Ap(w)[k]] }} >> k })[Ap(m)[k]] };

## subSafe :: forall t0. { Ap(rec r0.(t0 /\ < S(r0) | Zero >),rec r1.< S(r1) | Zero >)[t0] }
## total subtraction m from n
prd subSafe := cocase {
                 Ap(n,m)[k] => fix >>
                   Ap(cocase { Ap(alpha)[k] =>
                         cocase { Ap(n)[k] =>
                           cocase { Ap(m)[k] => m >>
                             case { Zero => n >> k
                                   , S(mp) => n >>
                                       case { Zero => n >> k
                                             , S(np) => alpha >>
                                                 Ap(np)[Ap(mp)[k]] }}} >> k } >> k })[Ap(n)[Ap(m)[k]]]};

## foldNat :: forall t0. { Ap(rec r0.< S(r0) | Zero >,t0,{ Ap(t0)[t0] })[t0] }
## folding over nats
prd foldNat := cocase {
                Ap(n,x,f)[k] => fix >>
                  Ap( cocase { Ap(alpha)[k] =>
                         cocase { Ap(n)[k] =>
                           cocase { Ap(x)[k] => n >>
                             case { Zero => x >> k
                                   , S(p) => f >>
                                       Ap(x)[mu w. alpha >>
                                         Ap(p)[Ap(w)[k]]] } } >> k } >> k })
                     [Ap(n)[Ap(x)[k]]] };

## foldNat1 :: forall t0t1. { Ap(rec r0.< S(r0) >,t1,{ Ap((t0 \/ t1))[t0] })[t0] }
## folding over nats
prd foldNat1 := cocase {
                  Ap(n,x,f)[k] => fix >>
                    Ap( cocase { Ap(alpha)[k] =>
                           cocase { Ap(n)[k] =>
                             cocase { Ap(x)[k] => n >>
                               case { S(m) => m >>
                                 case { Zero => f >>
                                   Ap(x)[k], S(p) => f >>
                                     Ap(x)[mu w. alpha >>
                                       Ap(m)[Ap(w)[k]]] }}} >> k } >> k })
                       [Ap(n)[Ap(x)[k]]]};


## ltUnsafe :: { Ap(rec r0.< S(r0) | Zero >,rec r1.< S(r1) >)[< True >] }
## "m < n" operator, where n > 0
prd ltUnsafe := cocase {
                  Ap(n,m)[k] => fix >>
                    Ap( cocase { Ap(alpha)[k] =>
                           cocase { Ap(n)[k] =>
                             cocase { Ap(m)[k] => n >>
                               case { Zero => True >> k
                                     , S(np) => m >>
                                         case { S(mp) => alpha >>
                                                   Ap(np)[Ap(mp)[k]] }}} >> k } >> k })
                       [Ap(n)[Ap(m)[k]]] };

## ltSafe  :: { Ap(rec r0.< S(r0) | Zero >,rec r0.< S(r0) | Zero >)[< False | True >] }
## "m < n" operator
prd ltSafe := cocase {
                Ap(n,m)[k] => fix >>
                  Ap(cocase {
                    Ap(alpha)[k] =>
                      cocase { Ap(n)[k] =>
                        cocase { Ap(m)[k] => n >>
                                    case { Zero => True >> k
                                          , S(np) => m >>
                                            case { Zero => False >> k
                                                  , S(mp) => alpha >>
                                                      Ap(np)[Ap(mp)[k]] }}} >> k } >> k })
                     [Ap(n)[Ap(m)[k]]] };

## eqUnsafe :: { Ap(rec r0.< S(r0) | Zero >,<  >)[< True >] }
## checks if n equals m
prd eqUnsafe := cocase {
                  Ap(n,m)[k] => fix >>
                    Ap( cocase { Ap(alpha)[k] =>
                      cocase { Ap(n)[k] =>
                        cocase { Ap(m)[k] => n >>
                          case { Zero => m >> case { Zero => True >> k }
                                , S(np) => m >> case { S(mp) => alpha >>
                                                           Ap(np)[Ap(mp)[k]] }}} >> k } >> k })
                       [Ap(n)[Ap(m)[k]]] };

## eqSafe :: { Ap(rec r0.< S(r0) | Zero >,rec r0.< S(r0) | Zero >)[< False | True >] }
## checks if n equals m
prd eqSafe := cocase {
                Ap(n,m)[k] => fix >>
                  Ap(cocase {
                    Ap(alpha)[k] =>
                      cocase { Ap(n)[k] =>
                        cocase { Ap(m)[k] => n >>
                          case { Zero => m >>
                            case { Zero => True >> k
                                  , S(mp) => False >> k }
                                , S(np) => m >>
                                    case { Zero => False >> k
                                          , S(mp) => alpha >>
                                              Ap(np)[Ap(mp)[k]] } } } >> k } >> k })
                     [Ap(n)[Ap(m)[k]]] };

## times2 :: { Ap(rec r0.< S(r0) | Zero >)[rec r1.< S(< S(r1) >) | Zero >] }
## multiplies n by two
prd times2 := cocase {
                Ap(n)[k] => fix >>
                  Ap( cocase {
                         Ap(alpha)[k] =>
                           cocase { Ap(n)[k] => n >>
                             case { Zero => Zero >> k
                                   , S(m) => alpha >> Ap(m)[mu w. S(S(w)) >> k]}} >> k })
                     [Ap(n)[k]]};

## times3 :: { Ap(rec r0.< S(r0) | Zero >)
##                [rec r1.< S(< S(< S(r1) >) >) | Zero >] }
## multiplies n by three
prd times3 := cocase {
                Ap(n)[k] => fix >>
                  Ap( cocase {
                         Ap(alpha)[k] =>
                           cocase { Ap(n)[k] => n >>
                            case { Zero => Zero >> k
                                  , S(m) => alpha >>
                                      Ap(m)[mu w. S(S(S(w))) >> k] } } >> k })
                     [Ap(n)[k]] };

## times2or3 :: { Ap(< False | True >
##                   , rec r1.< S(r1) | Zero >)
##                   [rec r3.< S(< S(< S(< S(< S(< S(r3) >) | Zero >) | Zero >) | Zero >) >) | Zero >] }
## multiplies n by two or three
prd times2or3 := cocase {
                   Ap(b,n)[k] => b >>
                     case { True => times2 >> Ap(n)[k]
                           , False => times3 >> Ap(n)[k] } };

## times2and3 :: { Ap(rec r0.< S(r0) | Zero >)[rec r1.< S(< S(r1) >) | Zero >] }
## multiplies n consecutively by two and three
prd times2and3 := cocase {
                    Ap(n)[k] => comp >>
                      Ap(times2, times3)[Ap(n)[k]]};

## div2 :: { Ap(rec r0.< S(< S(r0) >) | Zero >)[rec r1.< S(r1) | Zero >] }
## divides n by two
prd div2 := cocase {
              Ap(n)[k] => fix >>
                Ap( cocase { Ap(alpha)[k] =>
                       cocase { Ap(n)[k] => n >>
                                   case { Zero => Zero >> k
                                         , S(m) => m >>
                                             case { S(p) => alpha >>
                                              Ap(p)[mu w. S(w) >> k]}}} >> k })
                   [Ap(n)[k]] };

## div3 :: { Ap(rec r0.< S(< S(< S(r0) >) >) | Zero >)[rec r1.< S(r1) | Zero >] }
## divides n by three
prd div3 := cocase {
              Ap(n)[k] => fix >>
                Ap( cocase { Ap(alpha)[k] =>
                       cocase { Ap(n)[k] => n >>
                         case { Zero => Zero >> k
                               , S(m) => m >>
                                   case { S(p) => p >>
                                     case { S(r) => alpha >>
                                       Ap(r)[mu w. S(w) >> k] }}}} >> k })
                  [Ap(n)[k]]};

## div2or3 :: { Ap(< False | True >
##                 , rec r1.< S(< S(< S(< S(< S(< S(r1) >) >) >) >) >) | Zero >)
##                 [rec r8.< S(r8) | Zero >] }
## divides n by two or by three
prd div2or3 := cocase {
                 Ap(b,n)[k] => b >>
                   case { True  => div2 >> Ap(n)[k]
                         , False => div3 >> Ap(n)[k] }};

## pairs (data type)

## fst :: forall t0. { Ap(< Pair(t0,Top) >)[t0] }
## extract the first component of a pair
prd fst := cocase { Ap(p)[k] => p >> case { Pair(x,y) => x >> k }};

## snd :: forall t0. { Ap(< Pair(Top,t0) >)[t0] }
## extract the second component of a pair
prd snd := cocase { Ap(p)[k] => p >> case { Pair(x,y) => y >> k }};

## bimapDat :: forall t0t1t2t3. { Ap( { Ap(t3)[t1] } , { Ap(t2)[t0] } , < Pair(t3,t2) >)
##                                   [< Pair(t1,t0) >] }
## given two functions f and g, maps f to the first and g to the second component
prd bimapDat := cocase { Ap(f,g,p)[k] => p >>
                            case { Pair(x,y) => f >>
                                      Ap(x)[mu fx. g >>
                                              Ap(y)[mu gy. Pair(fx,gy) >> k]] }};

## pairs (codata type)

## pair :: forall t0t1. { Ap(t1,t0)[{ Fst[t1] , Snd[t0] }] }
## constructs a pair (x,y)
prd pair := cocase { Ap(x,y)[k] =>
                        cocase { Fst[k1] => x >> k1
                                , Snd[k2] => y >> k2 } >> k };

## bimapCodat :: forall t0t1t2t3. { Ap({ Ap(t2)[t3] },{ Ap(t0)[t1] },{ Fst[t2] , Snd[t0] })
##                                     [{ Fst[t3] , Snd[t1] }] }
## given two functions f and g, maps f to the first and g to the second component
prd bimapCodat := cocase { Ap(f,g,p)[k] =>
                    cocase {
                      Fst[k1] => p >>
                        Fst[mu x. f >> Ap(x)[k1]]
                    , Snd[k2] => p >>
                        Snd[mu y. g >> Ap(y)[k2]] }
                     >> k };

## lists (data type)

## map :: forall t0t1. { Ap( { Ap(t1)[t0] }
##                          , rec r1.< Cons(t1,r1) | Nil >)
##                          [rec r5.< Cons(t0,r5) | Nil >] }
## applies f to each element of xs
prd map := cocase {
             Ap(f, xs)[k] => fix >>
               Ap( cocase { Ap(alpha)[k] =>
                      cocase { Ap(xs)[k] => xs >>
                        case { Nil => Nil >> k
                              , Cons(p,ys) => alpha >>
                                  Ap(ys)[mu w1. f >>
                                    Ap(p)[mu w2. Cons(w2,w1) >> k]] } } >> k})
                  [Ap(xs)[k]]};

## head :: forall t0. { Ap(< Cons(t0,Top) >)[t0] }
## returns the head of the non-empty list xs
prd head := cocase { Ap(xs)[k] => xs >>
              case { Cons(x,xs) => x >> k }};

## tail :: forall t0. { Ap(< Cons(Top,t0) >)[t0] }
## returns the tail of the non-empty list xs
prd tail := cocase { Ap(xs)[k] => xs >> #
              case { Cons(x,xs) => xs >> k }};

## null :: { Ap(< Cons(Top,Top) | Nil >)[< False | True >] }
## returns True if a list is empty, otherwise False
prd null := cocase { Ap(xs)[k] => xs >>
              case { Nil => True >> k
                    , Cons(x,rest) => False >> k }};

## append :: forall t0t1. { Ap(rec r0.< Cons(t1,r0) | Nil >,t0)
##                             [rec r5.(t0 \/ < Cons(t1,r5) >)] }
## concatenates two lists
prd append := cocase { Ap(xs,ys)[k] => fix >>
                Ap( cocase { Ap(alpha)[k] =>
                       cocase { Ap(xs)[k] => xs >>
                         case { Nil          => ys >> k
                               , Cons(x,rest) => alpha >>
                                   Ap(rest)[mu w. Cons(x,w) >> k] }} >> k })
                   [Ap(xs)[k]]};

## elemAt :: forall t0. { Ap(rec r0.< Cons(t0,r0) >,rec r1.< S(r1) | Zero >)[t0] }
## gives the eleement at the index
prd elemAt := cocase { Ap(xs,n)[k] => fix >>
               Ap( cocase { Ap(alpha)[k] =>
                      cocase { Ap(xs)[k] =>
                        cocase { Ap(n)[k] => n >>
                          case { Zero    => head >> Ap(xs)[k]
                                , S(p) => tail >>
                                    Ap(xs)[mu w. alpha >>
                                                    Ap(w)[Ap(p)[k]]] }} >> k } >> k })
                  [Ap(xs)[Ap(n)[k]]] };

## foldl :: forall t0t1. { Ap({ Ap(t1,t0)[t1] },t1,rec r4.< Cons(t0,r4) | Nil >)[t1] }
## folds f over xs and gives x out in the empty case
prd foldl := cocase { Ap(f,x,xs)[k] => fix >>
              Ap( cocase { Ap(alpha)[k] =>
                     cocase { Ap(x)[k] =>
                       cocase { Ap(xs)[k] => xs >>
                         case { Nil => x >> k
                               , Cons(y,ys) => f >>
                                   Ap(x,y)[mu fxy.alpha >>
                                                    Ap(fxy)[Ap(ys)[k]]] } } >> k } >> k })
                 [Ap(x)[Ap(xs)[k]]] };

## reverse :: forall t0. { Ap(rec r0.< Cons(t0,r0) | Nil >)[rec r1.< Cons(t0,r1) | Nil >] }
## returns the elements of xs in reverse order
prd reverse := cocase { Ap(xs)[k] => fix >> #
                 Ap( cocase { Ap(alpha)[k] =>
                        cocase { Ap(xs)[k] => xs >>
                          case { Nil => Nil >> k
                                , Cons(x,rest) => alpha >>
                                    Ap(rest)[mu w. append >>
                                                      Ap(w,Cons(x,Nil))[k]] }} >> k })
                    [Ap(xs)[k]] };

## length :: { Ap(rec r0.< Cons(Top,r0) | Nil >)[rec r1.< S(r1) | Zero >] }
##  returns the number of items in a list
prd length := cocase { Ap(xs)[k] => fix >>
                Ap( cocase { Ap(alpha)[k] =>
                       cocase { Ap(xs)[k] => xs >>
                         case { Nil => Zero >> k
                               , Cons(x,rest) => alpha >>
                                   Ap(rest)[mu w. S(w) >> k]}} >> k })
                   [Ap(xs)[k]]};

## filter :: forall t0. { Ap( { Ap(t0)[< False | True >] }
##                           , rec r1.< Cons(t0,r1) | Nil >)
##                           [rec r5.< Cons(t0, r5) | Nil >] }
## filters out all elements of xs, not holding p
prd filter := cocase { Ap(p,xs)[k] => fix >>
                Ap( cocase { Ap(alpha)[k] =>
                       cocase { Ap(xs)[k] => xs >>
                         case { Nil => Nil >> k
                               , Cons(x,rest) => p >>
                                   Ap(x)[ case { True  => alpha >> Ap(rest)[mu w. Cons(x,w) >> k]
                                                 , False => alpha >> Ap(rest)[k] }] } } >> k })
                   [Ap(xs)[k]]};


## lists (codata type)

## consNeg :: forall t0t1. { Ap(t1,t0)[{ Head[t1] , Tail[t0] }] }
## inserts x as head in list xs
prd consNeg := cocase { Ap(x,xs)[k] =>
                 cocase { Head[k] => x >> k
                         , Tail[k] => xs >> k } >> k };

## mapNeg :: forall t0t1. { Ap( { Ap(t0)[t1] }
##                             , rec r1.{ Head[t0] , Tail[r1] })
##                             [rec r7.{ Head[t1] , Tail[r7] }] }
## applies f to each element of xs
prd mapNeg := cocase { Ap(f,xs)[k] => fix >>
               Ap( cocase { Ap(alpha)[k] =>
                      cocase { Ap(xs)[k] =>
                        cocase { Head[k] => xs >> Head[mu w. f >> Ap(w)[k]]#
                                , Tail[k] => xs >> Tail[mu w. alpha >>
                                                      Ap(w)[k]]} >> k } >> k })
                  [Ap(xs)[k]] };

## elemAtNeg :: forall t0. { Ap( rec r0.{ Head[t0] , Tail[r0] }
##                              , rec r1.< S(r1) | Zero >)
##                              [t0] }
## gives the eleement at the index
prd elemAtNeg := cocase { Ap(xs,n)[k] => fix >>
                   Ap( cocase { Ap(alpha)[k] =>
                          cocase { Ap(xs)[k] =>
                            cocase { Ap(n)[k] => n >>
                              case { Zero => xs >> Head[k]
                                    , S(m) => xs >> Tail[mu ys. alpha >>
                                                       Ap(ys)[Ap(m)[k]]] }} >> k } >> k })
                      [Ap(xs)[Ap(n)[k]]]};

## repeat :: forall t0. { Ap(t0)[rec r1.{ Head[t0] , Tail[r1] }] }
## creates an infinite list where all items are the first argument
prd repeat := cocase { Ap(x)[k] => fixLazy >>
                Ap( cocase { Ap(alpha)[k] =>
                       cocase { Head[k] => x >> k
                               , Tail[k] => alpha >> k } >> k })
                   [k]};


## misc interesting terms

# prd doubleCycle := cocase { Ap(x) => fix >> Ap(cocase { Ap(alpha)[k] => cocase { Ap(x) => x >> case { X(x1) => x1 >> case { X(x2) => alpha >> Ap(x2)}, Y(y1) => y1 >> case { Y(y2) => alpha >> Ap(y2)}}} >> k })[Ap(x)]};
prd faultyEdgeTest := cocase { Ap(b,f) => b >> case { True => f >> case { X(x) => Done, Y(x) => Done }, False => f >> case { X(x) => Done, Zero(x)=>Done }}};
prd oneortwo := cocase { Ap(b)[k] => b >> case { True => S(Zero) >> k, False => S(S(Zero)) >> k }};
prd admissabilityTest := cocase { Ap(f)[k] => True >> case { True => cocase { Ap(x)[k] => f >> Ap(x)[k]} >> k, False => f >> k }};

prd implicationConstraintsTest1 := cocase { Ap(x) => x >> case { A => Done, B => x >> case { B => Done }}};

prd parserTest := cocase { Ap(x)[x] => x >> x };

## Nominal Types

data Bool : CBV { TT, FF };
data Nat : CBV { Z, S(Nat) };
codata NatBoolFun : CBN { ApNB(Nat)[Bool] };
prd nominalNot := cocase { Ap(x)[k] => x >> case { TT => FF >> k, FF => TT >> k }};

prd addNominal := cocase { Ap(n,m)[k] => fix >> Ap( cocase { Ap(alpha)[k] => cocase { Ap(m)[k] => m >> case { Z => n >> k, S(p) => alpha >> Ap(p)[mu w. S(w) >> k] }} >> k })[Ap(m)[k]] };
prd mltNominal := cocase { Ap(n,m)[k] => fix >> Ap(cocase { Ap(alpha)[k] => cocase { Ap(m)[k] => m >> case { Z => Z >> k, S(p) => alpha >> Ap(p)[mu w. addNominal >> Ap(n,w)[k]] } } >> k })[Ap(m)[k]]};
prd expNominal := cocase { Ap(n,m)[k] => fix >> Ap(cocase { Ap(alpha)[k] => cocase { Ap(m)[k] => m >> case { Z => S(Z) >> k, S(p) => alpha >> Ap(p)[mu w. mltNominal >> Ap(n,w)[k]] } } >> k })[Ap(m)[k]] };
prd subSafeNominal := cocase { Ap(n,m)[k] => fix >> Ap(cocase { Ap(alpha)[k] => cocase { Ap(n)[k] => cocase { Ap(m)[k] => m >> case { Z => n >> k, S(mp) => n >> case { Z => n >> k, S(np) => alpha >> Ap(np)[Ap(mp)[k]] }}} >> k } >> k })[Ap(n)[Ap(m)[k]]]};

cmd exampleCommand1 := Print(2); Done ;
cmd exampleCommand2 := mu x.Print(2); Done >> mu y. Print(4); Done;

prd newStylePredTwo := (cocase { Ap(x)[*] => case x of { Z => Z, S(x) => x }}.Ap(S(S(S(Z))))[*]);
